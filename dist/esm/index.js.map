{
  "version": 3,
  "sources": ["../../AgentLib.mjs", "../../models/providers/modelsConfigLoader.mjs", "../../models/providers/providerRegistry.mjs", "../../models/providers/openai.mjs", "../../models/providers/messageAdapters/openAIChat.mjs", "../../models/providers/google.mjs", "../../models/providers/messageAdapters/googleGemini.mjs", "../../models/providers/anthropic.mjs", "../../models/providers/messageAdapters/anthropicMessages.mjs", "../../models/providers/huggingFace.mjs", "../../models/providers/messageAdapters/huggingFaceConversational.mjs", "../../models/providers/index.mjs", "../../models/providers/providerBootstrap.mjs", "../../LLMClient.mjs", "../../search/flexsearchAdapter.mjs", "../../skills/SkillRegistry.mjs", "../../models/modelCatalog.mjs", "../../invocation/modelInvoker.mjs", "../../agents/agentRegistry.mjs", "../../utils/json.mjs", "../../skills/SkillExecutor.mjs", "../../context/contextBuilder.mjs", "../../tasks/taskRunner.mjs", "../../operators/operatorRegistry.mjs"],
  "sourcesContent": ["import readline from 'node:readline';\n\nimport { cancelRequests as cancelLLMRequests } from './LLMClient.mjs';\nimport SkillRegistry from './skills/SkillRegistry.mjs';\nimport { executeSkill } from './skills/SkillExecutor.mjs';\nimport { buildSystemHistory } from './context/contextBuilder.mjs';\nimport {\n    commitAgentRecord,\n    getAgent,\n    listAgents as listRegisteredAgents,\n    registerDefaultLLMAgent as registerDefaultAgent,\n    resetAgentRegistryForTests,\n} from './agents/agentRegistry.mjs';\nimport {\n    buildModelRecordByName,\n    categorizeModelsByMode,\n    getOrderedModelNames,\n    normalizeModelNameList,\n    resetModelCatalogForTests,\n} from './models/modelCatalog.mjs';\nimport {\n    brainstormQuestion as runBrainstorm,\n    executeDeepTask,\n    executeFastTask,\n    executeIteration,\n    generatePlan,\n    normalizeTaskMode,\n    reviewCandidate,\n} from './tasks/taskRunner.mjs';\nimport { invokeAgent } from './invocation/modelInvoker.mjs';\nimport { safeJsonParse } from './utils/json.mjs';\nimport { callOperator, chooseOperator, registerOperator, resetOperatorRegistry } from './operators/operatorRegistry.mjs';\n\nlet agentLibraryInstance = null;\n\nfunction registerLLMAgent(options = {}) {\n    return getAgentLibrary().registerLLMAgent(options);\n}\n\nfunction registerDefaultLLMAgent(options = {}) {\n    return getAgentLibrary().registerDefaultLLMAgent(options);\n}\n\nasync function doTask(agentName, context, description, outputSchema = null, mode = 'fast', retries = 3) {\n    return getAgentLibrary().doTask(agentName, context, description, outputSchema, mode, retries);\n}\n\nasync function doTaskWithReview(agentName, context, description, outputSchema = null, mode = 'deep', maxIterations = 5) {\n    return getAgentLibrary().doTaskWithReview(agentName, context, description, outputSchema, mode, maxIterations);\n}\n\nasync function doTaskWithHumanReview(agentName, context, description, outputSchema = null, mode = 'deep') {\n    return getAgentLibrary().doTaskWithHumanReview(agentName, context, description, outputSchema, mode);\n}\n\nasync function brainstorm(agentName, question, generationCount, returnCount, reviewCriteria = null) {\n    return getAgentLibrary().brainstormQuestion(agentName, question, generationCount, returnCount, reviewCriteria);\n}\n\nfunction cancelTasks() {\n    getAgentLibrary().cancelTasks();\n}\n\nfunction listAgents() {\n    return listRegisteredAgents();\n}\n\nfunction resetForTests() {\n    resetOperatorRegistry();\n    resetAgentRegistryForTests();\n    resetModelCatalogForTests();\n    agentLibraryInstance = null;\n}\n\nclass Agent {\n    constructor(options = {}) {\n        const providedRegistry = options?.skillRegistry;\n        if (providedRegistry && typeof providedRegistry.registerSkill === 'function' && typeof providedRegistry.rankSkill === 'function') {\n            this.skillRegistry = providedRegistry;\n        } else {\n            this.skillRegistry = new SkillRegistry(options?.skillRegistryOptions);\n        }\n    }\n\n    async readUserPrompt(query) {\n        const rl = readline.createInterface({ input: process.stdin, output: process.stdout });\n        return new Promise(resolve => {\n            rl.question(query, answer => {\n                rl.close();\n                resolve(answer);\n            });\n        });\n    }\n\n    registerSkill(skillObj) {\n        return this.skillRegistry.registerSkill(skillObj);\n    }\n\n    async rankSkill(taskDescription, options = {}) {\n        const providedRole = typeof options.role === 'string' && options.role.trim()\n            ? options.role.trim()\n            : (typeof options.callerRole === 'string' && options.callerRole.trim()\n                ? options.callerRole.trim()\n                : '');\n\n        if (!providedRole) {\n            throw new Error('Agent rankSkill requires a role for access control.');\n        }\n\n        const verboseMode = options.verbose === true;\n        const startTime = options.startTime || Date.now();\n        \n        // Progressive display delay (configurable via env var, default 150ms)\n        const progressiveDelay = process.env.LLMAgentClient_VERBOSE_DELAY \n            ? parseInt(process.env.LLMAgentClient_VERBOSE_DELAY, 10)\n            : 150;\n        const useProgressiveDisplay = verboseMode && progressiveDelay > 0;\n        \n        const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n        \n        const flexSearchStart = Date.now();\n        const registryOptions = { ...options, role: providedRole };\n        const matches = this.skillRegistry.rankSkill(taskDescription, registryOptions);\n\n        if (!Array.isArray(matches) || matches.length === 0) {\n            if (verboseMode) {\n                const flexSearchTime = Date.now() - flexSearchStart;\n                console.log(`[FlexSearch] No matches found (${flexSearchTime}ms)`);\n            }\n            throw new Error('No skills matched the provided task description.');\n        }\n\n        if (verboseMode) {\n            const flexSearchTime = Date.now() - flexSearchStart;\n            console.log(`\\n[FlexSearch] Found ${matches.length} candidate${matches.length > 1 ? 's' : ''} (${flexSearchTime}ms):\\n`);\n            \n            if (useProgressiveDisplay) {\n                // Display candidates progressively with delays\n                for (let index = 0; index < matches.length; index++) {\n                    const name = matches[index];\n                    const skill = this.getSkill(name);\n                    const desc = skill?.description || skill?.what || 'No description';\n                    const truncated = desc.length > 70 ? desc.slice(0, 67) + '...' : desc;\n                    console.log(`  ${name}`);\n                    console.log(`  ${truncated}\\n`);\n                    \n                    // Add delay between candidates (but not after the last one)\n                    if (index < matches.length - 1) {\n                        await delay(progressiveDelay);\n                    }\n                }\n            } else {\n                // Display all at once (instant)\n                matches.forEach((name, index) => {\n                    const skill = this.getSkill(name);\n                    const desc = skill?.description || skill?.what || 'No description';\n                    const truncated = desc.length > 70 ? desc.slice(0, 67) + '...' : desc;\n                    console.log(`  ${name}`);\n                    console.log(`  ${truncated}\\n`);\n                });\n            }\n        }\n\n        if (matches.length === 1) {\n            if (verboseMode) {\n                console.log(`[Result] Single match found, using: ${matches[0]}`);\n            }\n            return matches[0];\n        }\n\n        const normalizeName = (value) => typeof value === 'string' ? value.trim().toLowerCase() : '';\n\n        const candidates = matches.map(name => {\n            const skill = this.getSkill(name);\n            if (!skill) {\n                return null;\n            }\n            const canonical = normalizeName(skill.name || name);\n            return {\n                canonical,\n                name: skill.name || name,\n                spec: skill,\n            };\n        }).filter(Boolean);\n\n        if (!candidates.length) {\n            throw new Error('Unable to load candidate skill specifications for selection.');\n        }\n\n        if (verboseMode) {\n            console.log(`\\n[LLM] Analyzing context to select best match...`);\n            console.log(`[LLM] Evaluating ${candidates.length} candidates`);\n        }\n\n        let selectorAgent;\n        try {\n            selectorAgent = getAgent(options?.agentName);\n        } catch (error) {\n            throw new Error(`Unable to obtain language model for skill selection: ${error.message}`);\n        }\n\n        const selectionMode = normalizeTaskMode(options?.mode || 'fast', null, selectorAgent, 'fast');\n\n        const candidateSummaries = candidates.map(entry => ({\n            name: entry.name,\n            description: entry.spec.description,\n            what: entry.spec.what,\n            why: entry.spec.why,\n            arguments: entry.spec.arguments,\n            requiredArguments: entry.spec.requiredArguments,\n            roles: entry.spec.roles,\n        }));\n\n        const contextPayload = {\n            taskDescription,\n            candidates: candidateSummaries,\n        };\n\n        const history = buildSystemHistory(selectorAgent, {\n            instruction: 'Review the candidate skills and choose the single best match for the task.',\n            context: JSON.stringify(contextPayload, null, 2),\n            description: 'Return JSON like {\"skill\": \"<skill name>\"}. If no skills are suitable, return {\"skill\": null}.',\n            mode: selectionMode,\n        });\n\n        const llmStart = Date.now();\n        const raw = await invokeAgent(selectorAgent, history, { mode: selectionMode });\n        \n        if (verboseMode) {\n            const llmTime = Date.now() - llmStart;\n            console.log(`[LLM] Selection completed (${llmTime}ms)`);\n        }\n\n        const candidateMap = new Map();\n        for (const candidate of candidates) {\n            candidateMap.set(candidate.canonical, candidate.name);\n        }\n\n        const parseSelection = (value) => {\n            const parsed = safeJsonParse(typeof value === 'string' ? value : '');\n            if (parsed && typeof parsed === 'object' && Object.prototype.hasOwnProperty.call(parsed, 'skill')) {\n                return parsed.skill;\n            }\n            return null;\n        };\n\n        let selected = parseSelection(raw);\n\n        if (selected === null || selected === undefined) {\n            if (typeof raw === 'string') {\n                const trimmed = raw.trim();\n                const normalized = normalizeName(trimmed);\n                if (candidateMap.has(normalized)) {\n                    selected = candidateMap.get(normalized);\n                }\n            }\n        }\n\n        if (selected === null || normalizeName(selected) === 'none' || normalizeName(selected) === 'no skill') {\n            throw new Error('No suitable skill was selected for the task description.');\n        }\n\n        if (typeof selected !== 'string' || !selected.trim()) {\n            throw new Error('Skill selection response was invalid.');\n        }\n\n        const normalizedSelected = normalizeName(selected);\n        if (!candidateMap.has(normalizedSelected)) {\n            throw new Error(`Selected skill \"${selected}\" was not among the matched candidates.`);\n        }\n\n        const finalSkill = candidateMap.get(normalizedSelected);\n        \n        if (verboseMode) {\n            console.log(`[Result] LLM selected: ${finalSkill}`);\n        }\n\n        return finalSkill;\n    }\n\n    async useSkill(skillName, providedArgs = {}, options = {}) {\n        const taskDescription = typeof options.taskDescription === 'string' ? options.taskDescription : '';\n        const skipConfirmation = options.skipConfirmation === true;\n        return executeSkill({\n            skillName,\n            providedArgs,\n            getSkill: this.getSkill.bind(this),\n            getSkillAction: this.getSkillAction.bind(this),\n            readUserPrompt: this.readUserPrompt.bind(this),\n            taskDescription,\n            skipConfirmation,\n        });\n    }\n\n    listSkillsForRole(role) {\n        return this.skillRegistry.listSkillsForRole(role);\n    }\n\n    getSkill(skillName) {\n        return this.skillRegistry.getSkill(skillName);\n    }\n\n    getSkillAction(skillName) {\n        return this.skillRegistry.getSkillAction(skillName);\n    }\n\n    clearSkills() {\n        this.skillRegistry.clear();\n    }\n\n    registerLLMAgent(options = {}) {\n        const {\n            name,\n            role = '',\n            job = '',\n            expertise = '',\n            instructions = '',\n            fastModels = [],\n            deepModels = [],\n            kind = 'task',\n            modelOrder = [],\n            origin = 'registerLLMAgent',\n        } = options;\n\n        if (!name || typeof name !== 'string') {\n            throw new Error('registerLLMAgent requires a non-empty \"name\".');\n        }\n\n        let normalizedFast = normalizeModelNameList(fastModels);\n        let normalizedDeep = normalizeModelNameList(deepModels);\n\n        if (!normalizedFast.length && !normalizedDeep.length) {\n            const fallbackNames = getOrderedModelNames();\n            const categorized = categorizeModelsByMode(fallbackNames);\n            normalizedFast = categorized.fast;\n            normalizedDeep = categorized.deep;\n        }\n\n        const explicitOrder = normalizeModelNameList(modelOrder);\n        const combinedOrder = [];\n        const seen = new Set();\n\n        const pushInOrder = (list) => {\n            for (const value of list) {\n                if (!seen.has(value)) {\n                    seen.add(value);\n                    combinedOrder.push(value);\n                }\n            }\n        };\n\n        if (explicitOrder.length) {\n            pushInOrder(explicitOrder);\n        }\n        pushInOrder(normalizedFast);\n        pushInOrder(normalizedDeep);\n\n        const configuredRecords = [];\n        for (const modelName of combinedOrder) {\n            const record = buildModelRecordByName(modelName);\n            if (record) {\n                configuredRecords.push(record);\n            }\n        }\n\n        return commitAgentRecord({\n            name,\n            role,\n            job,\n            expertise,\n            instructions,\n            kind,\n            configuredRecords,\n            fastModelNames: normalizedFast,\n            deepModelNames: normalizedDeep,\n            origin,\n        });\n    }\n\n    registerDefaultLLMAgent(options = {}) {\n        registerDefaultAgent(options);\n    }\n\n    async doTask(agentName, context, description, outputSchema = null, mode = 'fast', retries = 3) {\n        const agent = getAgent(agentName);\n        const normalizedMode = normalizeTaskMode(mode, outputSchema, agent);\n\n        let attempt = 0;\n        let lastError = null;\n\n        while (attempt < Math.max(retries, 1)) {\n            try {\n                if (normalizedMode === 'deep') {\n                    return await executeDeepTask(agent, context, description, outputSchema);\n                }\n                return await executeFastTask(agent, context, description, outputSchema);\n            } catch (error) {\n                lastError = error;\n                attempt += 1;\n            }\n        }\n\n        throw new Error(`Task failed after ${retries} retries: ${lastError?.message || 'unknown error'}`);\n    }\n\n    async doTaskWithReview(agentName, context, description, outputSchema = null, mode = 'deep', maxIterations = 5) {\n        const agent = getAgent(agentName);\n        const normalizedMode = normalizeTaskMode(mode, outputSchema, agent, 'deep');\n\n        const plan = normalizedMode === 'deep' ? await generatePlan(agent, context, description) : null;\n\n        let iteration = 0;\n        let feedback = '';\n\n        while (iteration < Math.max(maxIterations, 1)) {\n            iteration += 1;\n            const candidate = await executeIteration(agent, context, description, outputSchema, iteration, feedback, plan, normalizedMode);\n\n            const review = await reviewCandidate(agent, context, description, candidate.raw, outputSchema, iteration, normalizedMode);\n\n            if (review.approved) {\n                return candidate.parsed ?? { result: candidate.raw };\n            }\n\n            feedback = review.feedback || 'Improve and correct the prior answer.';\n        }\n\n        throw new Error('Maximum review iterations exceeded without an approved result.');\n    }\n\n    async doTaskWithHumanReview(agentName, context, description, outputSchema = null, mode = 'deep') {\n        const agent = getAgent(agentName);\n        const normalizedMode = normalizeTaskMode(mode, outputSchema, agent, 'deep');\n        const plan = normalizedMode === 'deep' ? await generatePlan(agent, context, description) : null;\n        let feedback = '';\n        let iteration = 0;\n\n        /* eslint-disable no-constant-condition */\n        while (true) {\n            iteration += 1;\n            const candidate = await executeIteration(agent, context, description, outputSchema, iteration, feedback || '', plan, normalizedMode);\n            const finalResult = candidate.parsed ?? { result: candidate.raw };\n\n            console.log('----- Agent Result -----');\n            console.log(typeof candidate.raw === 'string' ? candidate.raw : JSON.stringify(candidate.raw, null, 2));\n\n            const approval = await this.readUserPrompt('Is the result okay? [Y/n/cancel]: ');\n            const normalized = (approval || '').trim().toLowerCase();\n\n            if (normalized === '' || normalized === 'y' || normalized === 'yes') {\n                return finalResult;\n            }\n            if (normalized === 'cancel') {\n                throw new Error('Task cancelled by user.');\n            }\n\n            feedback = await this.readUserPrompt('Please provide feedback for the agent: ');\n        }\n        /* eslint-enable no-constant-condition */\n    }\n\n    cancelTasks() {\n        cancelLLMRequests();\n    }\n\n    async brainstormQuestion(agentName, question, generationCount, returnCount, reviewCriteria = null) {\n        return runBrainstorm(agentName, question, generationCount, returnCount, reviewCriteria);\n    }\n}\n\nfunction getAgentLibrary() {\n    if (!agentLibraryInstance) {\n        agentLibraryInstance = new Agent();\n    }\n    return agentLibraryInstance;\n}\n\nexport {\n    Agent,\n    brainstorm,\n    callOperator,\n    cancelTasks,\n    chooseOperator,\n    doTask,\n    doTaskWithHumanReview,\n    doTaskWithReview,\n    listAgents,\n    registerDefaultLLMAgent,\n    registerLLMAgent,\n    registerOperator,\n};\n\nexport const __resetForTests = resetForTests;\n", "import fs from 'node:fs';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nconst moduleFilename = typeof __filename === 'string'\n    ? __filename\n    : fileURLToPath(import.meta.url);\nconst moduleDirname = typeof __dirname === 'string'\n    ? __dirname\n    : path.dirname(moduleFilename);\n\nexport const DEFAULT_PROVIDER_ENV_MAP = {\n    openai: 'OPENAI_API_KEY',\n    google: 'GEMINI_API_KEY',\n    anthropic: 'ANTHROPIC_API_KEY',\n    mistral: 'MISTRAL_API_KEY',\n    openrouter: 'OPENROUTER_API_KEY',\n    deepseek: 'DEEPSEEK_API_KEY',\n    huggingface: 'HUGGINGFACE_API_KEY',\n};\n\nconst VALID_MODES = new Set(['fast', 'deep']);\n\nexport function loadRawConfig(configPath = path.join(moduleDirname, 'models.json')) {\n    if (!fs.existsSync(configPath)) {\n        return { raw: { providers: {}, models: {} }, issues: { errors: [`models.json not found at ${configPath}`], warnings: [] } };\n    }\n\n    try {\n        const rawContent = fs.readFileSync(configPath, 'utf-8');\n        const parsed = JSON.parse(rawContent);\n        return { raw: parsed || {}, issues: { errors: [], warnings: [] } };\n    } catch (error) {\n        return { raw: { providers: {}, models: {} }, issues: { errors: [`Failed to read models.json: ${error.message}`], warnings: [] } };\n    }\n}\n\nexport function normalizeConfig(rawConfig, options = {}) {\n    const issues = { errors: [], warnings: [] };\n    const providers = new Map();\n    const models = new Map();\n    const providerModels = new Map();\n    const orderedModelNames = [];\n\n    const rawProviders = rawConfig?.providers && typeof rawConfig.providers === 'object' ? rawConfig.providers : {};\n    const rawModels = Array.isArray(rawConfig?.models) ? rawConfig.models : [];\n\n    for (const [providerKey, entry] of Object.entries(rawProviders)) {\n        const normalized = normalizeProvider(providerKey, entry, issues, options);\n        providers.set(providerKey, normalized);\n        providerModels.set(providerKey, []);\n    }\n\n    for (const entry of rawModels) {\n        const normalized = normalizeModel(entry, providers, issues, options);\n        if (!normalized) {\n            continue;\n        }\n        const modelName = normalized.name;\n        models.set(modelName, normalized);\n        orderedModelNames.push(modelName);\n\n        if (!providerModels.has(normalized.providerKey)) {\n            providerModels.set(normalized.providerKey, []);\n        }\n        providerModels.get(normalized.providerKey).push(normalized);\n    }\n\n    validateProviders(providers, models, providerModels, issues);\n\n    return {\n        providers,\n        models,\n        providerModels,\n        issues,\n        raw: rawConfig,\n        orderedModels: orderedModelNames,\n    };\n}\n\nfunction normalizeProvider(providerKey, entry, issues, options) {\n    if (!entry || typeof entry !== 'object') {\n        issues.warnings.push(`Provider \"${providerKey}\" configuration must be an object.`);\n    }\n\n    const config = entry && typeof entry === 'object' ? entry : {};\n    const apiKeyEnv = selectString(config.apiKeyEnv, DEFAULT_PROVIDER_ENV_MAP[providerKey]);\n    if (!apiKeyEnv) {\n        issues.warnings.push(`Provider \"${providerKey}\" does not declare apiKeyEnv and no fallback is known.`);\n    }\n\n    const baseURL = selectString(config.baseURL, null);\n    if (!baseURL) {\n        issues.warnings.push(`Provider \"${providerKey}\" is missing baseURL; requests may fail unless overridden per model.`);\n    }\n\n    const modulePath = selectString(config.module, null);\n    const defaultModel = selectString(config.defaultModel, null);\n\n    return {\n        name: providerKey,\n        providerKey,\n        apiKeyEnv,\n        baseURL,\n        defaultModel,\n        module: modulePath,\n        extra: config.extra || {},\n    };\n}\n\nfunction normalizeModel(entry, providers, issues, options) {\n    const modelName = selectString(entry && typeof entry === 'object' ? entry.name : null, null);\n    let providerKey = null;\n    let mode = 'fast';\n    let apiKeyEnvOverride = null;\n    let baseURLOverride = null;\n\n    if (!modelName) {\n        issues.warnings.push('Model entry is missing required \"name\" property.');\n        return null;\n    }\n\n    if (entry && typeof entry === 'object') {\n        providerKey = entry.provider || entry.providerKey || null;\n        mode = normalizeMode(entry.mode ?? entry.modes, issues, `model \"${modelName}\"`);\n        apiKeyEnvOverride = selectString(entry.apiKeyEnv, null);\n        baseURLOverride = selectString(entry.baseURL, null);\n    } else {\n        issues.warnings.push(`Model \"${modelName}\" configuration must be an object.`);\n        return null;\n    }\n\n    if (!providerKey) {\n        issues.errors.push(`Model \"${modelName}\" is missing provider reference.`);\n        return null;\n    }\n\n    if (!providers.has(providerKey)) {\n        issues.warnings.push(`Model \"${modelName}\" references unknown provider \"${providerKey}\".`);\n    }\n\n    return {\n        name: modelName,\n        providerKey,\n        mode,\n        apiKeyEnv: apiKeyEnvOverride,\n        baseURL: baseURLOverride,\n    };\n}\n\nfunction normalizeMode(rawMode, issues, context) {\n    if (rawMode === undefined || rawMode === null) {\n        return 'fast';\n    }\n\n    if (Array.isArray(rawMode)) {\n        const normalized = rawMode\n            .filter(value => typeof value === 'string')\n            .map(value => value.toLowerCase())\n            .filter(value => VALID_MODES.has(value));\n\n        if (normalized.length > 1) {\n            issues.warnings.push(`Model configuration for ${context} lists multiple modes; using \"${normalized[0]}\".`);\n        }\n\n        if (normalized.length) {\n            return normalized[0];\n        }\n\n        issues.warnings.push(`No valid mode found for ${context}; defaulting to 'fast'.`);\n        return 'fast';\n    }\n\n    if (typeof rawMode === 'string') {\n        const lower = rawMode.toLowerCase();\n        if (VALID_MODES.has(lower)) {\n            return lower;\n        }\n    }\n\n    issues.warnings.push(`Invalid mode value for ${context}; defaulting to 'fast'.`);\n    return 'fast';\n}\n\nfunction validateProviders(providers, models, providerModels, issues) {\n    for (const provider of providers.values()) {\n        if (provider.defaultModel) {\n            const model = models.get(provider.defaultModel);\n            if (!model) {\n                issues.warnings.push(`Provider \"${provider.name}\" defaultModel \"${provider.defaultModel}\" is not defined.`);\n            } else if (model.providerKey !== provider.providerKey) {\n                issues.warnings.push(`Provider \"${provider.name}\" defaultModel \"${provider.defaultModel}\" belongs to provider \"${model.providerKey}\".`);\n            }\n        }\n\n        if (!providerModels.get(provider.providerKey)?.length) {\n            issues.warnings.push(`Provider \"${provider.name}\" has no models defined.`);\n        }\n    }\n}\n\nfunction selectString(preferred, fallback) {\n    if (typeof preferred === 'string' && preferred.trim()) {\n        return preferred.trim();\n    }\n    if (typeof fallback === 'string' && fallback.trim()) {\n        return fallback.trim();\n    }\n    return null;\n}\n\nexport function loadModelsConfiguration(options = {}) {\n    const configPath = options.configPath\n        || process.env.LLM_MODELS_CONFIG_PATH\n        || path.join(__dirname, 'models.json');\n    const { raw, issues: loadIssues } = loadRawConfig(configPath);\n    const normalized = normalizeConfig(raw, options);\n\n    normalized.issues.errors.push(...loadIssues.errors);\n    normalized.issues.warnings.push(...loadIssues.warnings);\n    normalized.path = configPath;\n    return normalized;\n}\n", "const registry = new Map();\n\nfunction normalizeKey(key) {\n    return typeof key === 'string' ? key.trim().toLowerCase() : '';\n}\n\nexport function registerProvider({ key, handler, metadata = {} }) {\n    const normalizedKey = normalizeKey(key);\n    if (!normalizedKey) {\n        throw new Error('registerProvider requires a non-empty provider key.');\n    }\n\n    if (!handler || typeof handler.callLLM !== 'function') {\n        throw new Error(`Provider \"${key}\" must expose a callLLM function.`);\n    }\n\n    registry.set(normalizedKey, {\n        key: normalizedKey,\n        handler,\n        metadata,\n    });\n}\n\nexport function getProviderRecord(key) {\n    const normalizedKey = normalizeKey(key);\n    if (!normalizedKey) {\n        return null;\n    }\n    return registry.get(normalizedKey) || null;\n}\n\nexport function getProvider(key) {\n    return getProviderRecord(key)?.handler || null;\n}\n\nexport function ensureProvider(key) {\n    const record = getProviderRecord(key);\n    if (!record) {\n        throw new Error(`Provider \"${key}\" is not registered. Ensure its module has been loaded.`);\n    }\n    return record.handler;\n}\n\nexport function listProviders() {\n    return Array.from(registry.keys());\n}\n\nexport function resetProviders() {\n    registry.clear();\n}\n", "import { toOpenAIChatMessages } from '../messageAdapters/openAIChat.mjs';\n\nexport async function callLLM(chatContext, options) {\n    if (!options || typeof options !== 'object') {\n        throw new Error('OpenAI provider requires invocation options.');\n    }\n\n    const { model, apiKey, baseURL, signal, params, headers } = options;\n    if (!model) {\n        throw new Error('OpenAI provider requires a model name.');\n    }\n    if (!apiKey) {\n        throw new Error('OpenAI provider requires an API key.');\n    }\n    if (!baseURL) {\n        throw new Error('OpenAI provider requires a baseURL.');\n    }\n\n    const convertedContext = toOpenAIChatMessages(chatContext);\n    const payload = {\n        model,\n        messages: convertedContext,\n    };\n\n    if (params && typeof params === 'object') {\n        Object.assign(payload, params);\n    }\n\n    const response = await fetch(baseURL, {\n        method: 'POST',\n        headers: {\n            Authorization: `Bearer ${apiKey}`,\n            'Content-Type': 'application/json',\n            ...(headers || {}),\n        },\n        body: JSON.stringify(payload),\n        signal,\n    });\n\n    if (!response.ok) {\n        const errorBody = await response.text();\n        throw new Error(`OpenAI API Error (${response.status}): ${errorBody}`);\n    }\n\n    const data = await response.json();\n    if (data.error) {\n        throw new Error(JSON.stringify(data.error));\n    }\n    return data.choices?.[0]?.message?.content;\n}\n", "export function toOpenAIChatMessages(chatContext = []) {\n    const convertedContext = [];\n    for (const reply of chatContext) {\n        const normalized = {\n            content: reply.message,\n        };\n\n        switch (reply.role) {\n            case 'system':\n                normalized.role = 'system';\n                break;\n            case 'assistant':\n            case 'ai':\n                normalized.role = 'assistant';\n                break;\n            case 'user':\n            case 'human':\n                normalized.role = 'user';\n                break;\n            case 'tool':\n            case 'function':\n            case 'observation':\n                normalized.role = 'tool';\n                break;\n            default:\n                normalized.role = 'user';\n                break;\n        }\n\n        convertedContext.push(normalized);\n    }\n    return convertedContext;\n}\n", "import { toGeminiPayload } from '../messageAdapters/googleGemini.mjs';\n\nexport async function callLLM(chatContext, options) {\n    if (!options || typeof options !== 'object') {\n        throw new Error('Google provider requires invocation options.');\n    }\n\n    const { model, apiKey, baseURL, signal, params, headers } = options;\n\n    if (!model) {\n        throw new Error('Google provider requires a model name.');\n    }\n    if (!apiKey) {\n        throw new Error('Google provider requires an API key.');\n    }\n    if (!baseURL) {\n        throw new Error('Google provider requires a baseURL.');\n    }\n\n    const convertedContext = toGeminiPayload(chatContext);\n    const payload = { ...convertedContext };\n    if (params && typeof params === 'object') {\n        Object.assign(payload, params);\n    }\n\n    const normalizedBase = baseURL.endsWith('/') ? baseURL : `${baseURL}/`;\n    const url = `${normalizedBase}${model}:generateContent?key=${apiKey}`;\n\n    const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n            ...(headers || {}),\n        },\n        body: JSON.stringify(payload),\n        signal,\n    });\n\n    if (!response.ok) {\n        const errorBody = await response.text();\n        throw new Error(`Google Generative API Error (${response.status}): ${errorBody}`);\n    }\n\n    const responseJSON = await response.json();\n    if (responseJSON.error) {\n        throw new Error(JSON.stringify(responseJSON.error));\n    }\n\n    return responseJSON.candidates?.[0]?.content?.parts?.[0]?.text;\n}\n", "export function toGeminiPayload(chatContext = []) {\n    const contents = [];\n    const systemInstruction = { parts: [] };\n\n    for (const reply of chatContext) {\n        if (reply.role === 'system') {\n            systemInstruction.parts.push({ text: reply.message });\n            continue;\n        }\n\n        const message = {\n            parts: [{ text: reply.message }],\n        };\n\n        if (reply.role === 'human' || reply.role === 'user') {\n            message.role = 'user';\n        } else if (reply.role === 'assistant' || reply.role === 'ai') {\n            message.role = 'model';\n        } else if (reply.role === 'tool' || reply.role === 'function' || reply.role === 'observation') {\n            message.role = 'model';\n        } else {\n            message.role = message.role || 'user';\n        }\n\n        contents.push(message);\n    }\n\n    return { contents, systemInstruction };\n}\n", "import { toAnthropicMessages } from '../messageAdapters/anthropicMessages.mjs';\n\nexport async function callLLM(chatContext, options) {\n    if (!options || typeof options !== 'object') {\n        throw new Error('Anthropic provider requires invocation options.');\n    }\n    const { model, apiKey, baseURL, signal, params, headers } = options;\n\n    if (!model) {\n        throw new Error('Anthropic provider requires a model name.');\n    }\n    if (!apiKey) {\n        throw new Error('Anthropic provider requires an API key.');\n    }\n    if (!baseURL) {\n        throw new Error('Anthropic provider requires a baseURL.');\n    }\n\n    const { messages, system } = toAnthropicMessages(chatContext);\n    const payload = {\n        model,\n        max_tokens: 1000,\n        messages,\n    };\n\n    if (system) {\n        payload.system = system;\n    }\n\n    if (params && typeof params === 'object') {\n        Object.assign(payload, params);\n    }\n\n    const response = await fetch(baseURL, {\n        method: 'POST',\n        headers: {\n            'x-api-key': apiKey,\n            'anthropic-version': '2023-06-01',\n            'Content-Type': 'application/json',\n            ...(headers || {}),\n        },\n        body: JSON.stringify(payload),\n        signal,\n    });\n\n    if (!response.ok) {\n        const errorBody = await response.text();\n        throw new Error(`Anthropic API Error (${response.status}): ${errorBody}`);\n    }\n\n    const data = await response.json();\n    if (data.error) {\n        throw new Error(JSON.stringify(data.error));\n    }\n    return data.content?.[0]?.text;\n}\n", "export function toAnthropicMessages(chatContext = []) {\n    const messages = [];\n    const systemParts = [];\n\n    for (const reply of chatContext) {\n        if (reply.role === 'system') {\n            systemParts.push(reply.message);\n            continue;\n        }\n\n        const message = {\n            role: (reply.role === 'assistant' || reply.role === 'ai') ? 'assistant' : 'user',\n            content: reply.message,\n        };\n\n        if (reply.role === 'tool' || reply.role === 'function' || reply.role === 'observation') {\n            message.role = 'assistant';\n        }\n\n        messages.push(message);\n    }\n\n    return {\n        system: systemParts.length ? systemParts.join('\\n\\n') : undefined,\n        messages,\n    };\n}\n", "import { toHuggingFacePrompt } from '../messageAdapters/huggingFaceConversational.mjs';\n\nexport async function callLLM(chatContext, options) {\n    if (!options || typeof options !== 'object') {\n        throw new Error('Hugging Face provider requires invocation options.');\n    }\n\n    const { model, apiKey, baseURL, signal, params, headers } = options;\n\n    if (!model) {\n        throw new Error('Hugging Face provider requires a model name.');\n    }\n    if (!baseURL) {\n        throw new Error('Hugging Face provider requires a baseURL.');\n    }\n\n    const normalizedBase = baseURL.endsWith('/') ? baseURL.slice(0, -1) : baseURL;\n    const url = `${normalizedBase}/${model}`;\n\n    const requestHeaders = {\n        'Content-Type': 'application/json',\n        ...(headers || {}),\n    };\n\n    if (apiKey) {\n        requestHeaders.Authorization = `Bearer ${apiKey}`;\n    }\n\n    const payload = {\n        inputs: toHuggingFacePrompt(chatContext),\n        parameters: {\n            return_full_text: false,\n            max_new_tokens: 500,\n        },\n    };\n\n    if (params && typeof params === 'object') {\n        const { parameters, ...rest } = params;\n        if (parameters && typeof parameters === 'object') {\n            payload.parameters = { ...payload.parameters, ...parameters };\n        }\n        Object.assign(payload, rest);\n    }\n\n    const response = await fetch(url, {\n        method: 'POST',\n        headers: requestHeaders,\n        body: JSON.stringify(payload),\n        signal,\n    });\n\n    if (!response.ok) {\n        const errorBody = await response.text();\n        if (response.status === 503) {\n            throw new Error('Hugging Face model is currently loading or unavailable (503 Service Unavailable). Please try again later.');\n        }\n        throw new Error(`Hugging Face API Error (${response.status}): ${errorBody}`);\n    }\n\n    const data = await response.json();\n\n    if (Array.isArray(data) && data[0]?.generated_text) {\n        return data[0].generated_text.trim();\n    }\n    if (data.error) {\n        throw new Error(`Hugging Face API Error: ${data.error}`);\n    }\n\n    return typeof data === 'string' ? data : JSON.stringify(data);\n}\n", "export function toHuggingFacePrompt(chatContext = []) {\n    const lines = chatContext.map(reply => {\n        const role = reply.role === 'human'\n            ? 'User'\n            : reply.role === 'system'\n                ? 'System'\n                : 'Assistant';\n        return `${role}: ${reply.message}`;\n    });\n\n    lines.push('Assistant: ');\n    return `${lines.join('\\n')}\\n`;\n}\n", "import { registerProvider } from '../providerRegistry.mjs';\nimport * as openai from './openai.mjs';\nimport * as google from './google.mjs';\nimport * as anthropic from './anthropic.mjs';\nimport * as huggingFace from './huggingFace.mjs';\n\n\nlet registered = false;\n\nexport function registerBuiltInProviders(options = {}) {\n    if (registered) {\n        return;\n    }\n\n    const skip = options.skip || process.env.PLOINKY_SKIP_BUILTIN_PROVIDERS === '1';\n    if (skip) {\n        registered = true;\n        return;\n    }\n\n    registerProvider({ key: 'openai', handler: openai, metadata: { module: './openai.mjs' } });\n    registerProvider({ key: 'google', handler: google, metadata: { module: './google.mjs' } });\n    registerProvider({ key: 'anthropic', handler: anthropic, metadata: { module: './anthropic.mjs' } });\n    registerProvider({ key: 'huggingface', handler: huggingFace, metadata: { module: './huggingFace.mjs' } });\n    registerProvider({ key: 'openrouter', handler: openai, metadata: { module: './openai.mjs' } });\n    registerProvider({ key: 'custom', handler: openai, metadata: { module: './openai.mjs' } });\n\n    registered = true;\n}\n\nexport const resetBuiltInProviders = () => { registered = false; };\n", "import path from 'node:path';\nimport { pathToFileURL } from 'node:url';\n\nimport { registerProvider } from './providerRegistry.mjs';\n\nasync function resolveModuleExports(moduleId, baseDir) {\n    const isRelativeOrAbsolute = moduleId.startsWith('.') || moduleId.startsWith('/');\n    const resolvedId = isRelativeOrAbsolute ? path.resolve(baseDir, moduleId) : moduleId;\n\n    if (isRelativeOrAbsolute) {\n        const moduleUrl = pathToFileURL(resolvedId).href;\n        const exports = await import(moduleUrl);\n        return { exports, resolvedId };\n    }\n\n    const exports = await import(resolvedId);\n    return { exports, resolvedId };\n}\n\nfunction extractHandler(exports) {\n    if (!exports) {\n        return null;\n    }\n\n    if (typeof exports.callLLM === 'function') {\n        return exports;\n    }\n\n    if (typeof exports === 'function') {\n        return { callLLM: exports };\n    }\n\n    if (exports.default) {\n        return extractHandler(exports.default);\n    }\n\n    return null;\n}\n\nexport async function registerProvidersFromConfig(modelsConfiguration, options = {}) {\n    const warnings = [];\n    const baseDir = options.baseDir\n        || (modelsConfiguration.path ? path.dirname(modelsConfiguration.path) : __dirname);\n\n    for (const provider of modelsConfiguration.providers.values()) {\n        const moduleId = provider.module;\n        if (!moduleId) {\n            continue;\n        }\n\n        try {\n            const { exports, resolvedId } = await resolveModuleExports(moduleId, baseDir);\n            const handler = extractHandler(exports);\n            if (!handler) {\n                warnings.push(`Provider \"${provider.providerKey}\" module \"${moduleId}\" does not export a callLLM handler.`);\n                continue;\n            }\n\n            registerProvider({\n                key: provider.providerKey,\n                handler,\n                metadata: {\n                    module: moduleId,\n                    resolvedModule: resolvedId,\n                    source: 'config',\n                },\n            });\n        } catch (error) {\n            warnings.push(`Failed to register provider \"${provider.providerKey}\" from module \"${moduleId}\": ${error.message}`);\n        }\n    }\n\n    if (warnings.length && modelsConfiguration?.issues?.warnings) {\n        modelsConfiguration.issues.warnings.push(...warnings);\n    }\n\n    return warnings;\n}\n", "import { loadModelsConfiguration } from './models/providers/modelsConfigLoader.mjs';\nimport { registerBuiltInProviders } from './models/providers/index.mjs';\nimport { registerProvidersFromConfig } from './models/providerBootstrap.mjs';\nimport { ensureProvider } from './models/providerRegistry.mjs';\n\nconst modelsConfiguration = loadModelsConfiguration();\n\nregisterBuiltInProviders();\nconst providersReady = (async () => {\n    await registerProvidersFromConfig(modelsConfiguration);\n})();\n\nconst llmCalls = [];\n\nfunction getModelMetadata(modelName) {\n    const modelDescriptor = modelsConfiguration.models.get(modelName);\n    if (!modelDescriptor) {\n        return null;\n    }\n    const providerConfig = modelsConfiguration.providers.get(modelDescriptor.providerKey) || null;\n    return {\n        model: modelDescriptor,\n        provider: providerConfig,\n    };\n}\n\nfunction resolveProviderKey(modelName, invocationOptions, metadata) {\n    if (invocationOptions.providerKey) {\n        return invocationOptions.providerKey;\n    }\n    if (metadata?.model?.providerKey) {\n        return metadata.model.providerKey;\n    }\n    if (metadata?.provider?.providerKey) {\n        return metadata.provider.providerKey;\n    }\n    throw new Error(`Model \"${modelName}\" is not configured with a provider.`);\n}\n\nexport async function callLLM(historyArray, prompt, options = {}) {\n    const modelName = options?.model;\n    if (!modelName || typeof modelName !== 'string') {\n        throw new Error('callLLM requires options.model to be specified.');\n    }\n    return callLLMWithModel(modelName, historyArray, prompt, options);\n}\n\nasync function callLLMWithModelInternal(modelName, historyArray, prompt, invocationOptions = {}) {\n    await providersReady;\n\n    const controller = new AbortController();\n    llmCalls.push(controller);\n\n    const history = Array.isArray(historyArray) ? historyArray.slice() : [];\n    if (prompt) {\n        history.push({ role: 'human', message: prompt });\n    }\n\n    const externalSignal = invocationOptions.signal;\n    if (externalSignal && typeof externalSignal.addEventListener === 'function') {\n        const abortHandler = () => controller.abort();\n        externalSignal.addEventListener('abort', abortHandler, { once: true });\n    }\n\n    try {\n        const metadata = getModelMetadata(modelName);\n        const providerKey = resolveProviderKey(modelName, invocationOptions, metadata);\n        const provider = ensureProvider(providerKey);\n\n        const baseURL = invocationOptions.baseURL\n            || metadata?.model?.baseURL\n            || metadata?.provider?.baseURL;\n\n        if (!baseURL) {\n            throw new Error(`Missing base URL for provider \"${providerKey}\" and model \"${modelName}\".`);\n        }\n\n        const apiKey = invocationOptions.apiKey || process.env.LLM_API_KEY;\n        if (!apiKey && providerKey !== 'huggingface') {\n            throw new Error(`Missing API key for provider \"${providerKey}\".`);\n        }\n\n        return await provider.callLLM(history, {\n            model: modelName,\n            providerKey,\n            apiKey,\n            baseURL,\n            signal: controller.signal,\n            params: invocationOptions.params || {},\n            headers: invocationOptions.headers || {},\n        });\n    } catch (error) {\n        throw error;\n    } finally {\n        const index = llmCalls.indexOf(controller);\n        if (index > -1) {\n            llmCalls.splice(index, 1);\n        }\n    }\n}\n\nlet callLLMWithModelImpl = callLLMWithModelInternal;\n\nexport async function callLLMWithModel(modelName, historyArray, prompt, invocationOptions = {}) {\n    return callLLMWithModelImpl(modelName, historyArray, prompt, invocationOptions);\n}\n\nexport function cancelRequests() {\n    llmCalls.forEach(controller => controller.abort());\n    llmCalls.length = 0;\n}\n\nexport function __setCallLLMWithModelForTests(fn) {\n    if (typeof fn !== 'function') {\n        throw new TypeError('Expected function when overriding callLLMWithModel implementation.');\n    }\n    callLLMWithModelImpl = fn;\n}\n\nexport function __resetCallLLMWithModelForTests() {\n    callLLMWithModelImpl = callLLMWithModelInternal;\n}\n", "import FlexSearch from 'flexsearch';\n\nconst DEFAULT_TYPE = 'index';\n\nconst STATIC_METHODS = [\n    'registerEncoder',\n    'registerDecoder',\n    'registerLanguage',\n    'registerMatcher',\n    'registerPipeline',\n    'registerStemmer',\n    'release',\n];\n\nfunction inferTypeFromInstance(candidate) {\n    if (typeof candidate?.get === 'function' || typeof candidate?.set === 'function') {\n        return 'document';\n    }\n    return DEFAULT_TYPE;\n}\n\nfunction isFlexSearchInstance(candidate) {\n    return Boolean(candidate && typeof candidate === 'object' && typeof candidate.add === 'function' && typeof candidate.search === 'function');\n}\n\nfunction resolveConstructor(flexsearchLib, type) {\n    const lib = flexsearchLib || FlexSearch;\n    if (!lib) {\n        throw new Error('FlexSearch module is not available.');\n    }\n    const upperType = (typeof type === 'string' ? type : DEFAULT_TYPE).toLowerCase();\n    if (upperType === 'document') {\n        if (!lib.Document) {\n            throw new Error('FlexSearch.Document constructor is not available.');\n        }\n        return lib.Document;\n    }\n    if (!lib.Index) {\n        throw new Error('FlexSearch.Index constructor is not available.');\n    }\n    return lib.Index;\n}\n\nfunction exposeInstanceMethods(target, source) {\n    if (!source) {\n        return;\n    }\n\n    const seen = new Set();\n\n    const bindMethod = (methodName, methodFn) => {\n        if (seen.has(methodName)) {\n            return;\n        }\n        if (methodName === 'constructor' || methodName in target) {\n            return;\n        }\n        if (typeof methodFn === 'function') {\n            Object.defineProperty(target, methodName, {\n                value: methodFn.bind(source),\n                writable: false,\n                enumerable: false,\n            });\n            seen.add(methodName);\n        }\n    };\n\n    let proto = Object.getPrototypeOf(source);\n    while (proto && proto !== Object.prototype) {\n        for (const name of Object.getOwnPropertyNames(proto)) {\n            const descriptor = Object.getOwnPropertyDescriptor(proto, name);\n            if (descriptor && typeof descriptor.value === 'function') {\n                bindMethod(name, descriptor.value);\n            }\n        }\n        proto = Object.getPrototypeOf(proto);\n    }\n\n    for (const name of Object.keys(source)) {\n        const value = source[name];\n        if (typeof value === 'function') {\n            bindMethod(name, value);\n        }\n    }\n}\n\nexport class FlexSearchAdapter {\n    constructor(configOrInstance = {}, options = {}) {\n        const typeProvided = options && Object.prototype.hasOwnProperty.call(options, 'type');\n        const typeHint = typeProvided ? options.type : undefined;\n        const flexsearchLib = options?.flexsearch;\n        if (isFlexSearchInstance(configOrInstance)) {\n            this.index = configOrInstance;\n            this.config = options.config || null;\n            this.type = typeof typeHint === 'string' ? typeHint : inferTypeFromInstance(this.index);\n        } else {\n            const ctor = resolveConstructor(flexsearchLib, typeHint);\n            this.config = configOrInstance || {};\n            this.index = new ctor(this.config);\n            this.type = typeof typeHint === 'string' ? typeHint : DEFAULT_TYPE;\n        }\n        exposeInstanceMethods(this, this.index);\n    }\n\n    getIndex() {\n        return this.index;\n    }\n\n    getType() {\n        return this.type;\n    }\n\n    clone(overrides = {}) {\n        const nextConfig = { ...(this.config || {}), ...overrides };\n        return new FlexSearchAdapter(nextConfig, { type: this.type });\n    }\n\n    hasMethod(name) {\n        return typeof this.index?.[name] === 'function';\n    }\n}\n\nfor (const methodName of STATIC_METHODS) {\n    if (typeof FlexSearch?.[methodName] === 'function') {\n        Object.defineProperty(FlexSearchAdapter, methodName, {\n            value: (...args) => FlexSearch[methodName](...args),\n            writable: false,\n            enumerable: false,\n        });\n    }\n}\n\nexport function createFlexSearchAdapter(config = {}, options = {}) {\n    return new FlexSearchAdapter(config, options);\n}\n\nexport function fromFlexSearchInstance(instance, options = {}) {\n    if (!isFlexSearchInstance(instance)) {\n        throw new TypeError('fromFlexSearchInstance expects a FlexSearch index instance.');\n    }\n    return new FlexSearchAdapter(instance, { ...options, config: options.config || null });\n}\n\nexport default FlexSearchAdapter;\n", "import { createFlexSearchAdapter } from '../search/flexsearchAdapter.mjs';\n\nconst DEFAULT_INDEX_OPTIONS = {\n    tokenize: 'forward',\n};\n\nconst SEARCHABLE_FIELDS = ['name', 'what', 'why', 'description', 'arguments', 'requiredArguments', 'roles'];\n\nconst VALIDATOR_PREFIX = '@';\nconst ENUMERATOR_PREFIX = '%';\n\nfunction isPlainObject(value) {\n    return !!value && typeof value === 'object' && !Array.isArray(value);\n}\n\nfunction normalizeToken(token) {\n    if (typeof token !== 'string') {\n        return '';\n    }\n    return token.trim();\n}\n\nfunction stripPrefix(value, prefix) {\n    if (!value || !prefix) {\n        return value;\n    }\n    return value.startsWith(prefix) ? value.slice(prefix.length) : value;\n}\n\nfunction resolveHandler(skillObj, name, kind) {\n    if (!name) {\n        return null;\n    }\n\n    const direct = skillObj && typeof skillObj[name] === 'function' ? skillObj[name] : null;\n    if (direct) {\n        return direct.bind(skillObj);\n    }\n\n    const containerNames = kind === 'validator'\n        ? ['argumentValidators', 'validators', 'validationHandlers']\n        : ['argumentEnumerators', 'enumerators', 'optionProviders'];\n\n    for (const containerName of containerNames) {\n        const container = skillObj && isPlainObject(skillObj[containerName]) ? skillObj[containerName] : null;\n        if (!container) {\n            continue;\n        }\n        const handler = typeof container[name] === 'function' ? container[name] : null;\n        if (handler) {\n            return handler.bind(skillObj);\n        }\n    }\n\n    return null;\n}\n\nfunction normalizeArgumentDefinition(argumentName, rawDefinition, skillObj) {\n    if (!isPlainObject(rawDefinition)) {\n        throw new TypeError(`Argument \"${argumentName}\" must be described with an object definition.`);\n    }\n\n    const description = typeof rawDefinition.description === 'string' ? rawDefinition.description : '';\n    const llmHint = typeof rawDefinition.llmHint === 'string' ? rawDefinition.llmHint : '';\n\n    const defaultValue = Object.prototype.hasOwnProperty.call(rawDefinition, 'default')\n        ? rawDefinition.default\n        : (Object.prototype.hasOwnProperty.call(rawDefinition, 'defaultValue') ? rawDefinition.defaultValue : undefined);\n\n    const typeToken = normalizeToken(rawDefinition.type);\n    const validatorToken = normalizeToken(rawDefinition.validator || rawDefinition.validation || rawDefinition.validate);\n    const enumToken = normalizeToken(rawDefinition.enum || rawDefinition.enumerator || rawDefinition.optionsProvider);\n\n    let baseType = null;\n    let validatorName = validatorToken ? stripPrefix(validatorToken, VALIDATOR_PREFIX) : '';\n    let enumeratorName = enumToken ? stripPrefix(enumToken, ENUMERATOR_PREFIX) : '';\n\n    if (typeToken) {\n        if (typeToken.startsWith(VALIDATOR_PREFIX)) {\n            validatorName = stripPrefix(typeToken, VALIDATOR_PREFIX);\n        } else if (typeToken.startsWith(ENUMERATOR_PREFIX)) {\n            enumeratorName = stripPrefix(typeToken, ENUMERATOR_PREFIX);\n        } else if (!baseType) {\n            baseType = typeToken.toLowerCase();\n        }\n    }\n\n    if (!baseType) {\n        const fallback = normalizeToken(rawDefinition.valueType || rawDefinition.baseType);\n        baseType = fallback ? fallback.toLowerCase() : 'string';\n    }\n\n    const staticOptions = Array.isArray(rawDefinition.options) ? rawDefinition.options.slice() : null;\n\n    let validator = validatorName ? resolveHandler(skillObj, validatorName, 'validator') : null;\n    if (validatorName && !validator && typeof rawDefinition.validator === 'function') {\n        validator = rawDefinition.validator.bind(skillObj);\n    }\n    if (!validator && typeof rawDefinition.validator === 'function') {\n        validator = rawDefinition.validator.bind(skillObj);\n    }\n\n    let enumerator = enumeratorName ? resolveHandler(skillObj, enumeratorName, 'enumerator') : null;\n    if (enumeratorName && !enumerator && typeof rawDefinition.enum === 'function') {\n        enumerator = rawDefinition.enum.bind(skillObj);\n    }\n    if (!enumerator && typeof rawDefinition.enum === 'function') {\n        enumerator = rawDefinition.enum.bind(skillObj);\n    }\n\n    if (validatorName && !validator) {\n        throw new Error(`Validator \"${validatorName}\" for argument \"${argumentName}\" was not found on the skill module.`);\n    }\n\n    if (enumeratorName && !enumerator) {\n        throw new Error(`Enumerator \"${enumeratorName}\" for argument \"${argumentName}\" was not found on the skill module.`);\n    }\n\n    if (!enumerator && staticOptions) {\n        enumerator = async () => staticOptions.slice();\n        enumeratorName = ''; // indicates inline list\n    }\n\n    return {\n        name: argumentName,\n        description,\n        llmHint,\n        type: baseType,\n        defaultValue,\n        validatorName: validatorName || '',\n        validator,\n        enumeratorName: enumeratorName || '',\n        enumerator,\n        hasStaticOptions: Array.isArray(staticOptions),\n    };\n}\n\nfunction toSearchableText(value) {\n    if (value === null || value === undefined) {\n        return '';\n    }\n    if (typeof value === 'string') {\n        return value;\n    }\n    if (Array.isArray(value)) {\n        return value.map(toSearchableText).join(' ');\n    }\n    if (typeof value === 'object') {\n        try {\n            return JSON.stringify(value);\n        } catch (error) {\n            return String(value);\n        }\n    }\n    return String(value);\n}\n\nfunction normalizeSearchResults(result) {\n    if (!result) {\n        return [];\n    }\n    if (Array.isArray(result)) {\n        return result.map(entry => {\n            if (typeof entry === 'string') {\n                return entry;\n            }\n            if (entry && typeof entry === 'object') {\n                if (typeof entry.id === 'string') {\n                    return entry.id;\n                }\n                if (typeof entry.doc === 'string') {\n                    return entry.doc;\n                }\n                if (typeof entry.key === 'string') {\n                    return entry.key;\n                }\n            }\n            return null;\n        }).filter(Boolean);\n    }\n    if (typeof result === 'object') {\n        if (Array.isArray(result.result)) {\n            return normalizeSearchResults(result.result);\n        }\n        if (Array.isArray(result.ids)) {\n            return result.ids.filter(id => typeof id === 'string');\n        }\n    }\n    return [];\n}\n\nfunction buildSearchText(skill) {\n    return SEARCHABLE_FIELDS\n        .map(field => toSearchableText(skill[field]))\n        .filter(Boolean)\n        .join(' ');\n}\n\nfunction normalizeSkillName(name) {\n    if (typeof name !== 'string') {\n        return '';\n    }\n    return name.trim().toLowerCase();\n}\n\nfunction sanitizeSpecs(specs) {\n    if (!specs || typeof specs !== 'object') {\n        throw new TypeError('Skill specifications must be provided as an object.');\n    }\n\n    const normalized = {};\n    const normalizedArguments = {};\n    let hasArguments = false;\n    let requiredArguments = [];\n\n    for (const key of Object.keys(specs)) {\n        const value = specs[key];\n        if (value === undefined) {\n            continue;\n        }\n\n        if (key === 'arguments') {\n            if (!isPlainObject(value)) {\n                throw new TypeError('Skill specification \"arguments\" must be an object keyed by argument name.');\n            }\n            for (const [argName, rawDefinition] of Object.entries(value)) {\n                if (typeof argName !== 'string' || !argName.trim()) {\n                    throw new Error('Argument names must be non-empty strings.');\n                }\n                normalizedArguments[argName.trim()] = rawDefinition;\n            }\n            hasArguments = true;\n            continue;\n        }\n\n        if (key === 'args') {\n            throw new Error('Skill specification no longer supports the \"args\" array. Use the \"arguments\" object instead.');\n        }\n\n        if (key === 'requiredArgs') {\n            throw new Error('Skill specification no longer supports \"requiredArgs\". Use \"requiredArguments\" instead.');\n        }\n\n        if (key === 'requiredArguments') {\n            if (!Array.isArray(value)) {\n                throw new TypeError('Skill specification \"requiredArguments\" must be an array of strings.');\n            }\n            requiredArguments = value\n                .map(entry => (typeof entry === 'string' ? entry.trim() : ''))\n                .filter(Boolean);\n            continue;\n        }\n\n        normalized[key] = value;\n    }\n\n    if (!hasArguments) {\n        throw new Error('Skill specification requires an \"arguments\" object describing inputs.');\n    }\n\n    normalized.arguments = normalizedArguments;\n    normalized.requiredArguments = requiredArguments;\n\n    if (!normalized.name || typeof normalized.name !== 'string') {\n        throw new Error('Skill specification requires a \"name\" string.');\n    }\n\n    if (!normalized.description || typeof normalized.description !== 'string') {\n        throw new Error('Skill specification requires a \"description\" string.');\n    }\n\n    return normalized;\n}\n\nexport default class SkillRegistry {\n    constructor(options = {}) {\n        const { flexSearchAdapter, indexOptions } = options;\n        this.index = flexSearchAdapter || createFlexSearchAdapter(indexOptions || DEFAULT_INDEX_OPTIONS);\n        this.skills = new Map();\n        this.actions = new Map();\n    }\n\n    registerSkill(skillObj) {\n        if (!skillObj || typeof skillObj !== 'object') {\n            throw new TypeError('registerSkill requires a skill configuration object.');\n        }\n\n        const { specs, action, roles } = skillObj;\n\n        if (!specs || typeof specs !== 'object') {\n            throw new TypeError('registerSkill requires a \"specs\" object.');\n        }\n\n        if (typeof action !== 'function') {\n            throw new TypeError('registerSkill requires a function action handler.');\n        }\n\n        const normalizedSpecs = sanitizeSpecs(specs);\n        const canonicalName = normalizeSkillName(normalizedSpecs.name);\n        if (!canonicalName) {\n            throw new Error('Skill specification requires a non-empty name.');\n        }\n\n        if (!Array.isArray(roles)) {\n            throw new TypeError('registerSkill requires a \"roles\" array.');\n        }\n\n        const normalizedRoles = Array.from(new Set(roles\n            .map(role => (typeof role === 'string' ? role.trim() : ''))\n            .filter(Boolean)\n            .map(role => role.toLowerCase())));\n\n        if (!normalizedRoles.length) {\n            throw new Error('registerSkill requires at least one role.');\n        }\n\n        const argumentOrder = Object.keys(normalizedSpecs.arguments);\n        const argumentMetadata = {};\n        const publicArguments = {};\n\n        for (const argumentName of argumentOrder) {\n            const rawDefinition = normalizedSpecs.arguments[argumentName];\n            const meta = normalizeArgumentDefinition(argumentName, rawDefinition, skillObj);\n            argumentMetadata[argumentName] = meta;\n\n            const publicEntry = {};\n            if (meta.type) {\n                publicEntry.type = meta.type;\n            }\n            if (meta.description) {\n                publicEntry.description = meta.description;\n            }\n            if (meta.llmHint) {\n                publicEntry.llmHint = meta.llmHint;\n            }\n            if (meta.defaultValue !== undefined) {\n                publicEntry.default = meta.defaultValue;\n            }\n            if (meta.validatorName) {\n                publicEntry.validator = `${VALIDATOR_PREFIX}${meta.validatorName}`;\n            }\n            if (meta.enumeratorName) {\n                publicEntry.enumerator = `${ENUMERATOR_PREFIX}${meta.enumeratorName}`;\n            } else if (meta.enumerator) {\n                publicEntry.enumerator = 'inline';\n            }\n            publicArguments[argumentName] = publicEntry;\n        }\n\n        const requiredArguments = Array.isArray(normalizedSpecs.requiredArguments)\n            ? normalizedSpecs.requiredArguments.slice()\n            : [];\n\n        const record = {\n            canonicalName,\n            ...normalizedSpecs,\n            arguments: publicArguments,\n            requiredArguments,\n            roles: normalizedRoles,\n            registeredAt: new Date().toISOString(),\n            argumentMetadata,\n            argumentOrder,\n        };\n\n        if (this.skills.has(canonicalName)) {\n            this.skills.delete(canonicalName);\n            this.actions.delete(canonicalName);\n            if (typeof this.index.remove === 'function') {\n                try {\n                    this.index.remove(canonicalName);\n                } catch (error) {\n                    // ignore removal issues; index will be refreshed via add below\n                }\n            }\n        }\n\n        this.skills.set(canonicalName, record);\n        this.actions.set(canonicalName, action);\n\n        const searchText = buildSearchText(record);\n        if (searchText) {\n            this.index.add(canonicalName, searchText);\n        }\n\n        return record.name;\n    }\n\n    rankSkill(taskDescription, options = {}) {\n        if (!this.skills.size) {\n            return [];\n        }\n        const query = typeof taskDescription === 'string' ? taskDescription.trim() : '';\n        if (!query) {\n            return [];\n        }\n\n        const normalizedRole = typeof options.role === 'string' && options.role.trim()\n            ? options.role.trim().toLowerCase()\n            : (typeof options.callerRole === 'string' && options.callerRole.trim()\n                ? options.callerRole.trim().toLowerCase()\n                : '');\n\n        if (!normalizedRole) {\n            throw new Error('rankSkill requires a caller role for access filtering.');\n        }\n\n        const limit = Number.isInteger(options.limit) && options.limit > 0 ? options.limit : options.limit === 0 ? 0 : 5;\n        const searchOptions = {\n            bool: options?.bool === 'and' ? 'and' : 'or',\n            suggest: true,\n            ...(limit ? { limit } : {}),\n        };\n\n        let rawResults;\n        try {\n            rawResults = this.index.search(query, searchOptions);\n        } catch (error) {\n            return [];\n        }\n        const matches = normalizeSearchResults(rawResults);\n        if (!matches.length) {\n            return [];\n        }\n        const seen = new Set();\n        const filtered = [];\n        for (const key of matches) {\n            const canonical = normalizeSkillName(key);\n            if (!canonical || seen.has(canonical)) {\n                continue;\n            }\n            if (this.skills.has(canonical)) {\n                const record = this.skills.get(canonical);\n                if (Array.isArray(record.roles) && record.roles.includes(normalizedRole)) {\n                    seen.add(canonical);\n                    filtered.push(record.name);\n                }\n            }\n            if (limit && filtered.length >= limit) {\n                break;\n            }\n        }\n        return filtered;\n    }\n\n    getSkill(skillName) {\n        const canonical = normalizeSkillName(skillName);\n        if (!canonical) {\n            return null;\n        }\n        return this.skills.get(canonical) || null;\n    }\n\n    getSkillAction(skillName) {\n        const canonical = normalizeSkillName(skillName);\n        if (!canonical) {\n            return null;\n        }\n        return this.actions.get(canonical) || null;\n    }\n\n    listSkillsForRole(role) {\n        const normalizedRole = typeof role === 'string' ? role.trim().toLowerCase() : '';\n        if (!normalizedRole) {\n            return [];\n        }\n\n        const toSummary = (record) => ({\n            name: record.name,\n            description: record.humanDescription || record.description || record.what || record.name,\n            needConfirmation: record.needConfirmation === true,\n        });\n\n        return Array.from(this.skills.values())\n            .filter(record => Array.isArray(record.roles) && record.roles.includes(normalizedRole))\n            .sort((a, b) => a.name.localeCompare(b.name))\n            .map(toSummary);\n    }\n\n    clear() {\n        this.skills.clear();\n        this.actions.clear();\n        if (typeof this.index.clear === 'function') {\n            this.index.clear();\n        }\n    }\n}\n", "import { loadModelsConfiguration } from './providers/modelsConfigLoader.mjs';\n\nconst modelsConfiguration = loadModelsConfiguration();\nlet configurationDiagnosticsEmitted = false;\n\nfunction emitConfigurationDiagnostics() {\n    if (configurationDiagnosticsEmitted) {\n        return;\n    }\n    configurationDiagnosticsEmitted = true;\n\n    for (const error of modelsConfiguration.issues.errors) {\n        if (process.env.LLMAgentClient_DEBUG === 'true') {\n            console.error(`LLMAgentClient: ${error}`);\n        }\n    }\n    for (const warning of modelsConfiguration.issues.warnings) {\n        if (process.env.LLMAgentClient_DEBUG === 'true') {\n            console.warn(`LLMAgentClient: ${warning}`);\n        }\n    }\n}\n\nfunction getModelsConfiguration() {\n    return modelsConfiguration;\n}\n\nfunction getProviderConfig(providerKey) {\n    return modelsConfiguration.providers.get(providerKey) || null;\n}\n\nfunction getModelDescriptor(modelName) {\n    return modelsConfiguration.models.get(modelName) || null;\n}\n\nfunction createAgentModelRecord(providerConfig, modelDescriptor) {\n    if (!providerConfig || !modelDescriptor) {\n        return null;\n    }\n\n    const apiKeyEnv = modelDescriptor.apiKeyEnv || providerConfig.apiKeyEnv || null;\n    const baseURL = modelDescriptor.baseURL || providerConfig.baseURL || null;\n    const mode = modelDescriptor.mode || 'fast';\n\n    return {\n        name: modelDescriptor.name,\n        providerKey: modelDescriptor.providerKey,\n        apiKeyEnv,\n        baseURL,\n        mode,\n    };\n}\n\nfunction cloneAgentModelRecord(record) {\n    return {\n        name: record.name,\n        providerKey: record.providerKey,\n        apiKeyEnv: record.apiKeyEnv,\n        baseURL: record.baseURL,\n        mode: record.mode || 'fast',\n    };\n}\n\nfunction normalizeModePreference(value) {\n    const normalized = typeof value === 'string' ? value.trim().toLowerCase() : '';\n    return normalized === 'deep' || normalized === 'fast' ? normalized : null;\n}\n\nfunction normalizeInvocationRequest(input) {\n    if (typeof input === 'string') {\n        return { mode: normalizeModePreference(input), modelName: null };\n    }\n\n    if (!input || typeof input !== 'object') {\n        return { mode: null, modelName: null };\n    }\n\n    const mode = normalizeModePreference(input.mode || input.preferredMode || input.modePreference);\n    const modelRaw = input.modelName || input.model || input.preferredModel;\n    const modelName = typeof modelRaw === 'string' && modelRaw.trim() ? modelRaw.trim() : null;\n\n    return { mode, modelName };\n}\n\nfunction getOrderedModelNames() {\n    if (Array.isArray(modelsConfiguration.orderedModels) && modelsConfiguration.orderedModels.length) {\n        return modelsConfiguration.orderedModels.slice();\n    }\n    return Array.from(modelsConfiguration.models.keys());\n}\n\nfunction categorizeModelsByMode(modelNames) {\n    const fast = [];\n    const deep = [];\n    for (const name of modelNames) {\n        const descriptor = getModelDescriptor(name);\n        if (!descriptor) {\n            continue;\n        }\n        if (descriptor.mode === 'deep') {\n            deep.push(name);\n        } else {\n            fast.push(name);\n        }\n    }\n    return { fast, deep };\n}\n\nfunction buildModelRecordByName(modelName) {\n    const descriptor = getModelDescriptor(modelName);\n    if (!descriptor) {\n        if (process.env.LLMAgentClient_DEBUG === 'true') {\n            console.warn(`LLMAgentClient: models.json does not define model \"${modelName}\".`);\n        }\n        return null;\n    }\n    const providerConfig = getProviderConfig(descriptor.providerKey);\n    if (!providerConfig) {\n        if (process.env.LLMAgentClient_DEBUG === 'true') {\n            console.warn(`LLMAgentClient: Model \"${modelName}\" references unknown provider \"${descriptor.providerKey}\".`);\n        }\n        return null;\n    }\n    return createAgentModelRecord(providerConfig, descriptor);\n}\n\nfunction dedupeRecordsByName(records) {\n    const seen = new Set();\n    const result = [];\n    for (const record of records) {\n        if (!record || !record.name) {\n            continue;\n        }\n        if (seen.has(record.name)) {\n            continue;\n        }\n        seen.add(record.name);\n        result.push(record);\n    }\n    return result;\n}\n\nfunction normalizeModelNameList(list) {\n    if (!Array.isArray(list)) {\n        return [];\n    }\n    return list\n        .map(value => (typeof value === 'string' ? value.trim() : ''))\n        .filter(Boolean);\n}\n\nfunction resetModelCatalogForTests() {\n    configurationDiagnosticsEmitted = false;\n}\n\nexport {\n    buildModelRecordByName,\n    categorizeModelsByMode,\n    cloneAgentModelRecord,\n    createAgentModelRecord,\n    dedupeRecordsByName,\n    emitConfigurationDiagnostics,\n    getModelDescriptor,\n    getModelsConfiguration,\n    getOrderedModelNames,\n    getProviderConfig,\n    normalizeInvocationRequest,\n    normalizeModePreference,\n    normalizeModelNameList,\n    resetModelCatalogForTests,\n};\n", "import { callLLMWithModel } from '../LLMClient.mjs';\nimport {\n    getProviderConfig,\n    normalizeInvocationRequest,\n} from '../models/modelCatalog.mjs';\n\nfunction buildLegacyInvocationConfig(agent) {\n    const providerKey = agent.providerKey || null;\n    const apiKeyEnv = agent.apiKeyEnv || null;\n    const baseURL = agent.baseURL || (providerKey ? getProviderConfig(providerKey)?.baseURL : null);\n    return {\n        record: {\n            name: agent.model,\n            providerKey,\n            apiKeyEnv,\n            baseURL,\n            mode: agent.modelMode || 'fast',\n        },\n        providerKey,\n        apiKeyEnv,\n        baseURL,\n    };\n}\n\nasync function invokeAgent(agent, history, options = {}) {\n    const request = normalizeInvocationRequest(options);\n\n    const {\n        record,\n        providerKey,\n        apiKeyEnv,\n        baseURL,\n    } = typeof agent.getInvocationConfig === 'function'\n            ? agent.getInvocationConfig(request)\n            : buildLegacyInvocationConfig(agent);\n\n    if (!record?.name) {\n        throw new Error(`Agent \"${agent.name}\" does not have a usable model.`);\n    }\n\n    const effectiveProviderKey = providerKey || record.providerKey;\n    const effectiveBaseURL = baseURL || getProviderConfig(effectiveProviderKey)?.baseURL;\n    if (!effectiveBaseURL) {\n        throw new Error(`Missing base URL for agent \"${agent.name}\" (${effectiveProviderKey || 'unknown provider'}).`);\n    }\n\n    const apiKeyName = apiKeyEnv || record.apiKeyEnv || agent.apiKeyEnv || null;\n    const apiKey = apiKeyName ? process.env[apiKeyName] : null;\n    if (!apiKey && effectiveProviderKey !== 'huggingface') {\n        throw new Error(`Missing API key for agent \"${agent.name}\" (${apiKeyName || 'unspecified env var'}).`);\n    }\n\n    return callLLMWithModel(record.name, [...history], null, {\n        apiKey,\n        baseURL: effectiveBaseURL,\n        providerKey: effectiveProviderKey,\n    });\n}\n\nexport {\n    buildLegacyInvocationConfig,\n    invokeAgent,\n};\n", "import {\n    buildModelRecordByName,\n    cloneAgentModelRecord,\n    dedupeRecordsByName,\n    emitConfigurationDiagnostics,\n    getModelsConfiguration,\n    getProviderConfig,\n    normalizeInvocationRequest,\n    normalizeModePreference,\n} from '../models/modelCatalog.mjs';\n\nconst PROVIDER_PRIORITY = ['openai', 'google', 'anthropic', 'openrouter', 'mistral', 'deepseek', 'huggingface'];\n\nlet agentRegistry = null;\nlet agentRegistrySummary = null;\nlet defaultAgentName = null;\n\nfunction ensureAgentSummary() {\n    if (!agentRegistrySummary) {\n        agentRegistrySummary = { active: [], inactive: [] };\n    }\n    return agentRegistrySummary;\n}\n\nfunction removeAgentFromSummary(name) {\n    if (!agentRegistrySummary) {\n        return;\n    }\n    const filter = (entries) => entries.filter(entry => entry.name !== name);\n    agentRegistrySummary.active = filter(agentRegistrySummary.active);\n    agentRegistrySummary.inactive = filter(agentRegistrySummary.inactive);\n}\n\nfunction createAgentRuntime(record) {\n    const runtime = { ...record };\n\n    const recordsByMode = new Map();\n    for (const modelRecord of runtime.availableModelRecords) {\n        const mode = normalizeModePreference(modelRecord.mode) || 'fast';\n        if (!recordsByMode.has(mode)) {\n            recordsByMode.set(mode, []);\n        }\n        recordsByMode.get(mode).push(modelRecord);\n    }\n\n    const getRecordForMode = (mode) => {\n        const normalized = normalizeModePreference(mode);\n        if (normalized && recordsByMode.has(normalized)) {\n            return recordsByMode.get(normalized)[0];\n        }\n        if (normalized === 'deep' && recordsByMode.has('fast')) {\n            return recordsByMode.get('fast')[0];\n        }\n        if (normalized === 'fast' && recordsByMode.has('deep')) {\n            return recordsByMode.get('deep')[0];\n        }\n        if (runtime.model) {\n            const configured = runtime.availableModelRecords.find(modelRecord => modelRecord.name === runtime.model);\n            if (configured) {\n                return configured;\n            }\n        }\n        return runtime.availableModelRecords[0] || null;\n    };\n\n    runtime.supportedModes = Array.from(recordsByMode.keys());\n\n    runtime.supportsMode = function supportsMode(mode) {\n        const normalized = normalizeModePreference(mode);\n        return normalized ? recordsByMode.has(normalized) : false;\n    };\n\n    const findRecordByName = (modelName) => {\n        if (!modelName) {\n            return null;\n        }\n        return runtime.availableModelRecords.find(modelRecord => modelRecord.name === modelName) || null;\n    };\n\n    const resolveRecord = (request) => {\n        const recordByName = findRecordByName(request.modelName);\n        if (recordByName) {\n            return recordByName;\n        }\n        return getRecordForMode(request.mode);\n    };\n\n    runtime.selectModelRecord = function selectModelRecord(request) {\n        const normalizedRequest = normalizeInvocationRequest(request);\n        return resolveRecord(normalizedRequest);\n    };\n\n    runtime.getInvocationConfig = function getInvocationConfig(request) {\n        const normalizedRequest = normalizeInvocationRequest(request);\n        const record = resolveRecord(normalizedRequest);\n        if (!record) {\n            throw new Error(`Agent \"${runtime.name}\" has no available models.`);\n        }\n\n        const providerKey = record.providerKey || runtime.providerKey || null;\n        const apiKeyEnv = record.apiKeyEnv || runtime.apiKeyEnv || null;\n        const baseURL = record.baseURL\n            || runtime.baseURL\n            || (providerKey ? getProviderConfig(providerKey)?.baseURL : null);\n\n        return {\n            record,\n            providerKey,\n            apiKeyEnv,\n            baseURL,\n        };\n    };\n\n    return runtime;\n}\n\nfunction hasAvailableKey(record) {\n    if (!record) {\n        return false;\n    }\n    if (!record.apiKeyEnv) {\n        return true;\n    }\n    if ((record.providerKey || '').toLowerCase() === 'huggingface') {\n        return true;\n    }\n    return Boolean(process.env[record.apiKeyEnv]);\n}\n\nfunction commitAgentRecord({\n    name,\n    role = '',\n    job = '',\n    expertise = '',\n    instructions = '',\n    kind = 'task',\n    configuredRecords = [],\n    fastModelNames = [],\n    deepModelNames = [],\n    origin = 'config',\n}) {\n    if (!name || typeof name !== 'string') {\n        throw new Error('commitAgentRecord requires a non-empty name.');\n    }\n\n    if (!agentRegistry) {\n        agentRegistry = new Map();\n    }\n\n    const normalizedKind = kind === 'task' ? 'task' : 'chat';\n    const summaryState = ensureAgentSummary();\n    removeAgentFromSummary(name);\n\n    const orderedRecords = dedupeRecordsByName(configuredRecords || []);\n    const primaryProviderKey = orderedRecords[0]?.providerKey || null;\n\n    if (!orderedRecords.length) {\n        summaryState.inactive.push({\n            name,\n            kind: normalizedKind,\n            role,\n            job,\n            expertise,\n            instructions,\n            providerKey: primaryProviderKey,\n            reason: 'no models configured',\n            origin,\n        });\n        agentRegistry.delete(name.toLowerCase());\n        if (process.env.LLMAgentClient_DEBUG === 'true') {\n            console.warn(`LLMAgentClient: Agent \"${name}\" could not be registered because no models were supplied.`);\n        }\n        return { status: 'inactive', reason: 'no models configured' };\n    }\n\n    const availableRecords = orderedRecords.filter(hasAvailableKey);\n    if (!availableRecords.length) {\n        summaryState.inactive.push({\n            name,\n            kind: normalizedKind,\n            role,\n            job,\n            expertise,\n            instructions,\n            providerKey: primaryProviderKey,\n            reason: 'missing API keys',\n            origin,\n        });\n        agentRegistry.delete(name.toLowerCase());\n        if (process.env.LLMAgentClient_DEBUG === 'true') {\n            console.warn(`LLMAgentClient: Agent \"${name}\" has no models with available API keys.`);\n        }\n        return { status: 'inactive', reason: 'missing API keys' };\n    }\n\n    const defaultRecord = availableRecords[0];\n    const fastSet = new Set((fastModelNames || []).map(value => value?.toString().trim()).filter(Boolean));\n    const deepSet = new Set((deepModelNames || []).map(value => value?.toString().trim()).filter(Boolean));\n\n    const fastRecords = availableRecords.filter(record => fastSet.has(record.name) || (fastSet.size === 0 && record.mode === 'fast'));\n    const deepRecords = availableRecords.filter(record => deepSet.has(record.name) || (deepSet.size === 0 && record.mode === 'deep'));\n\n    const agentRecord = {\n        name,\n        canonicalName: name,\n        role,\n        job,\n        expertise,\n        instructions,\n        kind: normalizedKind,\n        origin,\n        model: defaultRecord.name,\n        modelMode: defaultRecord.mode,\n        apiKeyEnv: defaultRecord.apiKeyEnv || null,\n        providerKey: defaultRecord.providerKey || null,\n        baseURL: defaultRecord.baseURL || null,\n        availableModels: availableRecords.map(record => record.name),\n        availableModelRecords: availableRecords.map(cloneAgentModelRecord),\n        configuredModels: orderedRecords.map(record => record.name),\n        fastModels: fastRecords.map(record => record.name),\n        deepModels: deepRecords.map(record => record.name),\n        supportedModes: Array.from(new Set(availableRecords.map(record => record.mode).filter(Boolean))),\n    };\n\n    const runtimeAgent = createAgentRuntime(agentRecord);\n\n    agentRegistry.set(name.toLowerCase(), runtimeAgent);\n\n    summaryState.active.push({\n        name,\n        kind: normalizedKind,\n        role,\n        job,\n        expertise,\n        instructions,\n        origin,\n        providerKey: runtimeAgent.providerKey,\n        defaultModel: runtimeAgent.model,\n        availableModels: runtimeAgent.availableModels.slice(),\n        fastModels: runtimeAgent.fastModels.slice(),\n        deepModels: runtimeAgent.deepModels.slice(),\n    });\n\n    return { status: 'active', agent: runtimeAgent };\n}\n\nfunction autoRegisterProviders() {\n    const modelsConfiguration = getModelsConfiguration();\n    for (const providerConfig of modelsConfiguration.providers.values()) {\n        const providerKey = providerConfig.providerKey;\n        const descriptors = modelsConfiguration.providerModels.get(providerKey) || [];\n\n        if (!descriptors.length) {\n            if (process.env.LLMAgentClient_DEBUG === 'true') {\n                console.warn(`LLMAgentClient: No models configured in models.json for provider \"${providerKey}\".`);\n            }\n            commitAgentRecord({\n                name: providerKey,\n                role: `${providerKey} agent`,\n                job: `Handle requests using ${providerKey} models.`,\n                expertise: 'General',\n                instructions: '',\n                kind: 'task',\n                configuredRecords: [],\n                origin: 'provider',\n            });\n            continue;\n        }\n\n        const orderedNames = Array.isArray(modelsConfiguration.orderedModels)\n            ? modelsConfiguration.orderedModels.filter(name => descriptors.some(descriptor => descriptor.name === name))\n            : descriptors.map(descriptor => descriptor.name);\n\n        const configuredRecords = [];\n        for (const modelName of orderedNames) {\n            const record = buildModelRecordByName(modelName);\n            if (record && record.providerKey === providerKey) {\n                configuredRecords.push(record);\n            }\n        }\n\n        const fastNames = descriptors.filter(descriptor => descriptor.mode === 'fast').map(descriptor => descriptor.name);\n        const deepNames = descriptors.filter(descriptor => descriptor.mode === 'deep').map(descriptor => descriptor.name);\n\n        commitAgentRecord({\n            name: providerKey,\n            role: providerConfig.extra?.role || `${providerKey} agent`,\n            job: providerConfig.extra?.job || `Handle requests routed to ${providerKey}.`,\n            expertise: providerConfig.extra?.expertise || 'Provider specialist',\n            instructions: providerConfig.extra?.instructions || '',\n            kind: providerConfig.extra?.kind || providerConfig.extra?.type || 'task',\n            configuredRecords,\n            fastModelNames: fastNames,\n            deepModelNames: deepNames,\n            origin: 'provider',\n        });\n    }\n}\n\nfunction determineDefaultAgent() {\n    defaultAgentName = null;\n    if (!agentRegistry || agentRegistry.size === 0) {\n        return;\n    }\n\n    if (agentRegistry.has('default')) {\n        defaultAgentName = 'default';\n        return;\n    }\n\n    for (const name of PROVIDER_PRIORITY) {\n        if (agentRegistry.has(name)) {\n            defaultAgentName = name;\n            return;\n        }\n    }\n\n    const firstAgent = agentRegistry.keys().next();\n    if (!firstAgent.done) {\n        defaultAgentName = firstAgent.value;\n    }\n}\n\nfunction ensureAgentRegistry() {\n    if (agentRegistry) {\n        return agentRegistry;\n    }\n\n    emitConfigurationDiagnostics();\n\n    agentRegistry = new Map();\n    agentRegistrySummary = { active: [], inactive: [] };\n\n    autoRegisterProviders();\n    registerDefaultLLMAgent({});\n\n    determineDefaultAgent();\n    return agentRegistry;\n}\n\nfunction getAgent(agentName) {\n    const registry = ensureAgentRegistry();\n    if (!registry || registry.size === 0) {\n        throw new Error('No agents are configured. Set provider API keys in the environment.');\n    }\n\n    if (agentName) {\n        const normalized = agentName.toLowerCase();\n        if (registry.has(normalized)) {\n            return registry.get(normalized);\n        }\n    }\n\n    if (defaultAgentName && registry.has(defaultAgentName)) {\n        return registry.get(defaultAgentName);\n    }\n\n    throw new Error('Default agent is not configured.');\n}\n\nfunction cloneAgentSummary(summary) {\n    return {\n        name: summary.name,\n        kind: summary.kind,\n        role: summary.role,\n        job: summary.job,\n        expertise: summary.expertise,\n        instructions: summary.instructions,\n        origin: summary.origin,\n        providerKey: summary.providerKey || null,\n        defaultModel: summary.defaultModel,\n        availableModels: Array.isArray(summary.availableModels) ? summary.availableModels.slice() : [],\n        fastModels: Array.isArray(summary.fastModels) ? summary.fastModels.slice() : [],\n        deepModels: Array.isArray(summary.deepModels) ? summary.deepModels.slice() : [],\n        reason: summary.reason,\n    };\n}\n\nfunction listAgents() {\n    ensureAgentRegistry();\n\n    const summaries = agentRegistrySummary || { active: [], inactive: [] };\n\n    return {\n        defaultAgent: defaultAgentName,\n        agents: {\n            active: summaries.active.map(cloneAgentSummary),\n            inactive: summaries.inactive.map(cloneAgentSummary),\n        },\n    };\n}\n\nfunction registerDefaultLLMAgent(options = {}) {\n    const {\n        role = 'General-purpose assistant',\n        job = 'Plan and execute tasks accurately and reliably.',\n        expertise = 'Generalist',\n        instructions = 'Select the most capable model for each request.',\n        kind = 'task',\n    } = options;\n\n    const modelsConfiguration = getModelsConfiguration();\n    const orderedNames = Array.isArray(modelsConfiguration.orderedModels)\n        ? modelsConfiguration.orderedModels.slice()\n        : Array.from(modelsConfiguration.models.keys());\n\n    const configuredRecords = [];\n    const fastNames = [];\n    const deepNames = [];\n\n    for (const modelName of orderedNames) {\n        const record = buildModelRecordByName(modelName);\n        if (!record) {\n            continue;\n        }\n        configuredRecords.push(record);\n        if (record.mode === 'fast') {\n            fastNames.push(record.name);\n        }\n        if (record.mode === 'deep') {\n            deepNames.push(record.name);\n        }\n    }\n\n    commitAgentRecord({\n        name: 'default',\n        role,\n        job,\n        expertise,\n        instructions,\n        kind,\n        configuredRecords,\n        fastModelNames: fastNames,\n        deepModelNames: deepNames,\n        origin: 'default',\n    });\n}\n\nfunction resetAgentRegistryForTests() {\n    agentRegistry = null;\n    agentRegistrySummary = null;\n    defaultAgentName = null;\n}\n\nexport {\n    commitAgentRecord,\n    createAgentRuntime,\n    determineDefaultAgent,\n    ensureAgentRegistry,\n    getAgent,\n    listAgents,\n    registerDefaultLLMAgent,\n    resetAgentRegistryForTests,\n};\n", "function safeJsonParse(value) {\n    if (typeof value !== 'string') {\n        return value;\n    }\n\n    let text = value.trim();\n\n    // Strip Markdown-style code fences so JSON.parse has a clean payload.\n    const fenceMatch = text.match(/^```(?:json)?\\s*([\\s\\S]*?)```$/i);\n    if (fenceMatch) {\n        text = fenceMatch[1].trim();\n    }\n\n    if (!text.startsWith('{') && !text.startsWith('[')) {\n        const startBrace = text.indexOf('{');\n        const startBracket = text.indexOf('[');\n        const startCandidates = [startBrace, startBracket].filter(index => index !== -1);\n        if (startCandidates.length) {\n            const start = Math.min(...startCandidates);\n            const endBrace = text.lastIndexOf('}');\n            const endBracket = text.lastIndexOf(']');\n            const endCandidates = [endBrace, endBracket].filter(index => index !== -1);\n            if (endCandidates.length) {\n                const end = Math.max(...endCandidates);\n                if (end >= start) {\n                    text = text.slice(start, end + 1).trim();\n                }\n            }\n        }\n    }\n\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\n\nexport {\n    safeJsonParse,\n};\n", "import { invokeAgent } from '../invocation/modelInvoker.mjs';\nimport { getAgent } from '../agents/agentRegistry.mjs';\nimport { safeJsonParse } from '../utils/json.mjs';\nimport { createFlexSearchAdapter } from '../search/flexsearchAdapter.mjs';\n\nasync function executeSkill({\n    skillName,\n    providedArgs = {},\n    getSkill,\n    getSkillAction,\n    readUserPrompt,\n    taskDescription = '',\n    skipConfirmation = false,\n}) {\n    if (typeof getSkill !== 'function') {\n        throw new Error('executeSkill requires a getSkill function.');\n    }\n    if (typeof getSkillAction !== 'function') {\n        throw new Error('executeSkill requires a getSkillAction function.');\n    }\n    if (typeof readUserPrompt !== 'function') {\n        throw new Error('executeSkill requires a readUserPrompt function.');\n    }\n\n    const skill = getSkill(skillName);\n    if (!skill) {\n        throw new Error(`Skill \"${skillName}\" is not registered.`);\n    }\n\n    const action = getSkillAction(skillName);\n    if (typeof action !== 'function') {\n        throw new Error(`No executable action found for skill \"${skillName}\".`);\n    }\n\n    const normalizedArgs = providedArgs && typeof providedArgs === 'object' ? { ...providedArgs } : {};\n    const requiredArguments = Array.isArray(skill.requiredArguments)\n        ? skill.requiredArguments.filter(name => typeof name === 'string' && name)\n        : [];\n\n    const argumentMetadata = skill.argumentMetadata && typeof skill.argumentMetadata === 'object'\n        ? skill.argumentMetadata\n        : {};\n\n    const argumentOrder = Array.isArray(skill.argumentOrder) && skill.argumentOrder.length\n        ? skill.argumentOrder.filter(name => typeof name === 'string' && name)\n        : Object.keys(argumentMetadata);\n\n    const argumentDefinitions = argumentOrder\n        .map(name => argumentMetadata[name])\n        .filter(entry => entry && typeof entry.name === 'string' && entry.name);\n\n    const definitionNames = argumentDefinitions.map(def => def.name);\n    const allArgumentNames = definitionNames.length\n        ? definitionNames\n        : Array.from(new Set(requiredArguments));\n    const requiredArgSet = new Set(requiredArguments);\n    const optionalArgumentNames = allArgumentNames.filter(name => !requiredArgSet.has(name));\n\n    const validatorMap = new Map(argumentDefinitions\n        .filter(def => typeof def.validator === 'function')\n        .map(def => [def.name, def.validator]));\n\n    const enumeratorMap = new Map(argumentDefinitions\n        .filter(def => typeof def.enumerator === 'function')\n        .map(def => [def.name, def.enumerator]));\n\n    const definitionMap = new Map(argumentDefinitions.map(def => [def.name, def]));\n\n    const hasArgumentValue = (name) => Object.prototype.hasOwnProperty.call(normalizedArgs, name)\n        && normalizedArgs[name] !== undefined\n        && normalizedArgs[name] !== null;\n\n    const missingArgsFromList = (names) => names.filter((name) => !hasArgumentValue(name));\n\n    const optionMap = new Map();\n    const optionIndexMap = new Map();\n    const debugMode = process.env.LLMAgentClient_DEBUG === 'true';\n    const toComparableToken = (input) => {\n        if (input === undefined) {\n            return '';\n        }\n        if (input === null) {\n            return 'null';\n        }\n        if (typeof input === 'string') {\n            return input.trim().toLowerCase().replace(/\\s+/g, '');\n        }\n        if (typeof input === 'number' || typeof input === 'boolean') {\n            return String(input).toLowerCase();\n        }\n        try {\n            return JSON.stringify(input).toLowerCase();\n        } catch (error) {\n            return String(input).toLowerCase();\n        }\n    };\n\n    const stringifyOptionValue = (value) => {\n        if (value === null) {\n            return 'null';\n        }\n        if (value === undefined) {\n            return 'undefined';\n        }\n        if (typeof value === 'string') {\n            return value;\n        }\n        if (typeof value === 'number' || typeof value === 'boolean') {\n            return String(value);\n        }\n        try {\n            return JSON.stringify(value);\n        } catch (error) {\n            return String(value);\n        }\n    };\n\n    const createOptionEntries = (values) => {\n        const entries = [];\n        for (const entry of values) {\n            if (entry === null || entry === undefined) {\n                continue;\n            }\n            if (typeof entry === 'object' && Object.prototype.hasOwnProperty.call(entry, 'label') && Object.prototype.hasOwnProperty.call(entry, 'value')) {\n                const rawLabel = entry.label === null || entry.label === undefined ? '' : String(entry.label).trim();\n                if (!rawLabel) {\n                    continue;\n                }\n                const option = {\n                    label: rawLabel,\n                    value: entry.value,\n                };\n                option.labelToken = toComparableToken(option.label);\n                option.valueToken = toComparableToken(option.value);\n                const valueForDisplay = stringifyOptionValue(option.value);\n                option.display = option.label === valueForDisplay\n                    ? option.label\n                    : `${option.label} (${valueForDisplay})`;\n                entries.push(option);\n                continue;\n            }\n\n            if (typeof entry === 'string' || typeof entry === 'number' || typeof entry === 'boolean') {\n                const label = String(entry);\n                const option = {\n                    label,\n                    value: entry,\n                };\n                option.labelToken = toComparableToken(option.label);\n                option.valueToken = toComparableToken(option.value);\n                option.display = option.label;\n                entries.push(option);\n            }\n        }\n        return entries;\n    };\n\n    for (const [name, enumerator] of enumeratorMap.entries()) {\n        try {\n            const values = await Promise.resolve(enumerator());\n            if (Array.isArray(values)) {\n                const entries = createOptionEntries(values);\n                if (entries.length) {\n                    optionMap.set(name, entries);\n                    \n                    // Create FlexSearch index for this argument's options\n                    const searchIndex = createFlexSearchAdapter({ tokenize: 'forward' });\n                    for (const option of entries) {\n                        const searchText = `${option.label} ${option.display}`;\n                        searchIndex.add(option.labelToken, searchText);\n                    }\n                    optionIndexMap.set(name, searchIndex);\n                }\n            }\n        } catch (error) {\n            console.warn(`Failed to load options for argument \"${name}\" on skill \"${skill.name}\": ${error.message}`);\n        }\n    }\n\n    const matchOptionWithFlexSearch = (name, value) => {\n        const searchIndex = optionIndexMap.get(name);\n        const options = optionMap.get(name);\n        \n        if (!searchIndex || !options || !options.length) {\n            return { matched: false, confidence: 0, value: null, matches: [] };\n        }\n        \n        const candidateToken = toComparableToken(value);\n        if (!candidateToken) {\n            return { matched: false, confidence: 0, value: null, matches: [] };\n        }\n        \n        // First try exact match\n        for (const option of options) {\n            if (candidateToken === option.labelToken || candidateToken === option.valueToken) {\n                if (debugMode) {\n                    console.log(`[FlexSearch] Exact match for \"${name}\": \"${value}\" \u2192 \"${option.label}\"`);\n                }\n                return { matched: true, confidence: 1.0, value: option.value, matches: [option] };\n            }\n        }\n        \n        // Try FlexSearch fuzzy matching\n        let searchResults;\n        try {\n            searchResults = searchIndex.search(candidateToken, { limit: 5 });\n        } catch (error) {\n            return { matched: false, confidence: 0, value: null, matches: [] };\n        }\n        \n        if (!Array.isArray(searchResults) || searchResults.length === 0) {\n            if (debugMode) {\n                console.log(`[FlexSearch] No matches for \"${name}\": \"${value}\"`);\n            }\n            return { matched: false, confidence: 0, value: null, matches: [] };\n        }\n        \n        // Convert search results back to option objects\n        const matchedOptions = searchResults\n            .map(resultToken => options.find(opt => opt.labelToken === resultToken))\n            .filter(Boolean);\n        \n        if (matchedOptions.length === 0) {\n            return { matched: false, confidence: 0, value: null, matches: [] };\n        }\n        \n        // Calculate confidence based on result clarity\n        let confidence = 0;\n        if (matchedOptions.length === 1) {\n            // Single clear match - high confidence\n            confidence = 0.9;\n        } else if (matchedOptions.length >= 2) {\n            // Multiple matches - low confidence (ambiguous)\n            confidence = 0.3;\n        }\n        \n        if (debugMode) {\n            if (confidence >= 0.8) {\n                console.log(`[FlexSearch] High-confidence match for \"${name}\": \"${value}\" \u2192 \"${matchedOptions[0].label}\"`);\n            } else {\n                console.log(`[FlexSearch] Low-confidence match for \"${name}\": \"${value}\" \u2192 [${matchedOptions.map(o => o.label).join(', ')}]`);\n            }\n        }\n        \n        return {\n            matched: confidence >= 0.8,\n            confidence,\n            value: matchedOptions[0].value,\n            matches: matchedOptions.slice(0, 3)\n        };\n    };\n\n    const normalizeOptionValue = (name, value) => {\n        const options = optionMap.get(name);\n        if (!options || !options.length) {\n            return { valid: true, value };\n        }\n        \n        // Try FlexSearch first\n        const flexResult = matchOptionWithFlexSearch(name, value);\n        if (flexResult.matched) {\n            return { valid: true, value: flexResult.value };\n        }\n        \n        return { valid: false, value: null };\n    };\n\n    const validateArgumentValue = (name, value) => {\n        const validator = validatorMap.get(name);\n        if (typeof validator !== 'function') {\n            return { valid: true, value };\n        }\n\n        try {\n            const result = validator(value);\n            if (result === false) {\n                console.warn(`Validation for argument \"${name}\" rejected the provided value.`);\n                return { valid: false, value: null };\n            }\n            if (result === true || result === undefined) {\n                return { valid: true, value };\n            }\n            if (result && typeof result === 'object' && Object.prototype.hasOwnProperty.call(result, 'valid')) {\n                const normalizedValue = Object.prototype.hasOwnProperty.call(result, 'value') ? result.value : value;\n                if (!result.valid) {\n                    const message = typeof result.message === 'string' ? result.message : 'validator returned false';\n                    console.warn(`Validation for argument \"${name}\" failed: ${message}`);\n                }\n                return { valid: Boolean(result.valid), value: normalizedValue };\n            }\n            return { valid: true, value: result };\n        } catch (error) {\n            const message = error?.message || 'validator threw an error';\n            console.warn(`Validation for argument \"${name}\" failed: ${message}`);\n            return { valid: false, value: null };\n        }\n    };\n\n    const coerceScalarValue = (raw) => {\n        const value = typeof raw === 'string' ? raw.trim() : raw;\n        if (typeof value !== 'string') {\n            return value;\n        }\n        if (!value.length) {\n            return value;\n        }\n        const lower = value.toLowerCase();\n        if (lower === 'true') {\n            return true;\n        }\n        if (lower === 'false') {\n            return false;\n        }\n        if (lower === 'null') {\n            return null;\n        }\n        if (/^-?\\d+(\\.\\d+)?([eE][+-]?\\d+)?$/.test(value)) {\n            const numeric = Number(value);\n            if (!Number.isNaN(numeric)) {\n                return numeric;\n            }\n        }\n        if ((value.startsWith('{') && value.endsWith('}')) || (value.startsWith('[') && value.endsWith(']'))) {\n            const parsed = safeJsonParse(value);\n            if (parsed !== null) {\n                return parsed;\n            }\n        }\n        return value;\n    };\n\n    const sanitizeInitialArguments = () => {\n        const currentEntries = Object.entries({ ...normalizedArgs });\n        for (const [name, raw] of currentEntries) {\n            if (!argumentMetadata[name]) {\n                continue;\n            }\n            const optionCheck = normalizeOptionValue(name, raw);\n            if (!optionCheck.valid) {\n                delete normalizedArgs[name];\n                continue;\n            }\n            const candidate = optionMap.has(name)\n                ? optionCheck.value\n                : raw;\n            const validation = validateArgumentValue(name, candidate);\n            if (!validation.valid) {\n                delete normalizedArgs[name];\n                continue;\n            }\n            normalizedArgs[name] = validation.value;\n        }\n    };\n\n    sanitizeInitialArguments();\n\n    const escapeRegex = (text) => text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n\n    // Build argument name variations mapping (includes space-separated and no-separator versions)\n    const argumentNameVariationsMap = new Map();\n    for (const argName of allArgumentNames) {\n        const variations = [argName];\n        // Add space-separated version: job_name \u2192 \"job name\"\n        const spaceSeparated = argName.replace(/_/g, ' ');\n        if (spaceSeparated !== argName) {\n            variations.push(spaceSeparated);\n        }\n        // Add no-separator version: job_name \u2192 \"jobname\"\n        const noSeparator = argName.replace(/_/g, '');\n        if (noSeparator !== argName && noSeparator !== spaceSeparated) {\n            variations.push(noSeparator);\n        }\n        // Map each variation to the canonical name\n        for (const variant of variations) {\n            argumentNameVariationsMap.set(variant.toLowerCase(), argName);\n        }\n    }\n\n    const parseNamedArguments = (input, candidateNames) => {\n        const resolved = new Map();\n        const invalid = new Set();\n\n        if (!input || !candidateNames.length) {\n            return { resolved, invalid };\n        }\n\n        // Build all variations for the candidate names (including space-separated)\n        const allVariations = [];\n        const variationToCanonical = new Map();\n        \n        for (const name of candidateNames) {\n            const variations = [name];\n            const spaceSeparated = name.replace(/_/g, ' ');\n            if (spaceSeparated !== name) {\n                variations.push(spaceSeparated);\n            }\n            const noSeparator = name.replace(/_/g, '');\n            if (noSeparator !== name && noSeparator !== spaceSeparated) {\n                variations.push(noSeparator);\n            }\n            \n            for (const variant of variations) {\n                allVariations.push(variant);\n                variationToCanonical.set(variant.toLowerCase(), name);\n            }\n        }\n\n        // Sort by length (longest first) to match \"job name\" before \"job\"\n        allVariations.sort((a, b) => b.length - a.length);\n        \n        const nameAlternatives = allVariations.map(escapeRegex).join('|');\n        const pattern = new RegExp(String.raw`\\b(${nameAlternatives})\\b\\s*(?::|=)?\\s*(\"[^\"]*\"|'[^']*'|[^\\s\"']+)`, 'gi');\n\n        let match;\n        while ((match = pattern.exec(input)) !== null) {\n            const rawName = match[1];\n            const canonical = variationToCanonical.get(rawName.toLowerCase());\n            if (!canonical) {\n                continue;\n            }\n\n            if (resolved.has(canonical)) {\n                invalid.add(canonical);\n                continue;\n            }\n\n            let rawValue = match[2] || '';\n            rawValue = rawValue.trim();\n\n            if (!rawValue.length) {\n                invalid.add(canonical);\n                continue;\n            }\n\n            if ((rawValue.startsWith('\"') && rawValue.endsWith('\"')) || (rawValue.startsWith(\"'\") && rawValue.endsWith(\"'\"))) {\n                rawValue = rawValue.slice(1, -1);\n            }\n\n            rawValue = rawValue.trim();\n            if (!rawValue.length) {\n                invalid.add(canonical);\n                continue;\n            }\n\n            const optionCheck = normalizeOptionValue(canonical, rawValue);\n            if (!optionCheck.valid) {\n                invalid.add(canonical);\n                continue;\n            }\n\n            const candidate = optionMap.has(canonical)\n                ? optionCheck.value\n                : coerceScalarValue(rawValue);\n\n            const validation = validateArgumentValue(canonical, candidate);\n            if (!validation.valid) {\n                invalid.add(canonical);\n                continue;\n            }\n\n            resolved.set(canonical, validation.value);\n        }\n\n        return { resolved, invalid };\n    };\n\n    const resolveFieldName = (name) => {\n        if (typeof name !== 'string') {\n            return null;\n        }\n        const trimmed = name.trim();\n        if (!trimmed) {\n            return null;\n        }\n        if (allArgumentNames.includes(trimmed)) {\n            return trimmed;\n        }\n        const lower = trimmed.toLowerCase();\n        const direct = allArgumentNames.find(candidate => candidate.toLowerCase() === lower);\n        if (direct) {\n            return direct;\n        }\n\n        // Check skill-provided argument aliases for domain-specific keyword mappings\n        // Example: argumentAliases: { name: ['job', 'project'], customer: ['client'] }\n        const argumentAliases = skill.argumentAliases && typeof skill.argumentAliases === 'object'\n            ? skill.argumentAliases\n            : {};\n\n        for (const [targetArg, keywords] of Object.entries(argumentAliases)) {\n            if (!allArgumentNames.includes(targetArg)) {\n                continue;\n            }\n            if (!Array.isArray(keywords) || !keywords.length) {\n                continue;\n            }\n            const lowerKeywords = keywords.map(k => String(k).toLowerCase());\n            if (lowerKeywords.some(keyword => lower.includes(keyword))) {\n                return targetArg;\n            }\n        }\n\n        // Fuzzy matching as fallback\n        const fuzzy = allArgumentNames.find(candidate => {\n            const canonical = candidate.toLowerCase();\n            const distance = Math.abs(canonical.length - lower.length);\n            return distance <= 2 && (canonical.startsWith(lower) || lower.startsWith(canonical));\n        });\n        return fuzzy || null;\n    };\n\n    const applyUpdatesMap = (updates) => {\n        if (!updates || typeof updates !== 'object') {\n            return 'unchanged';\n        }\n\n        let applied = false;\n        for (const [rawName, rawValue] of Object.entries(updates)) {\n            const field = resolveFieldName(rawName);\n            if (!field) {\n                continue;\n            }\n            const currentValue = normalizedArgs[field];\n            const hasValue = hasArgumentValue(field);\n            const optionCheck = normalizeOptionValue(field, rawValue);\n            if (!optionCheck.valid) {\n                continue;\n            }\n\n            const candidateValue = optionMap.has(field)\n                ? optionCheck.value\n                : coerceScalarValue(rawValue);\n\n            const validation = validateArgumentValue(field, candidateValue);\n            if (!validation.valid) {\n                continue;\n            }\n\n            const nextValue = validation.value;\n\n            const valuesMatch = () => {\n                if (!hasValue) {\n                    return false;\n                }\n                const current = currentValue;\n                if (typeof current === 'string' && typeof nextValue === 'string') {\n                    return current.trim() === nextValue.trim();\n                }\n                return current === nextValue;\n            };\n\n            if (valuesMatch()) {\n                continue;\n            }\n\n            normalizedArgs[field] = nextValue;\n            applied = true;\n        }\n\n        if (!applied) {\n            return 'unchanged';\n        }\n\n        return missingRequiredArgs().length > 0 ? 'needsMissing' : 'updated';\n    };\n\n    const applyDescriptionDefaults = () => {\n        for (const definition of argumentDefinitions) {\n            if (!definition || typeof definition.name !== 'string') {\n                continue;\n            }\n            if (hasArgumentValue(definition.name)) {\n                continue;\n            }\n            const desc = typeof definition.description === 'string' ? definition.description : '';\n            const defaultMatch = desc.match(/defaults? to\\s+([^.]+)/i);\n            if (defaultMatch && defaultMatch[1]) {\n                const rawDefault = defaultMatch[1]\n                    .replace(/[\"']/g, '')\n                    .replace(/[)\\.]+$/, '')\n                    .trim();\n                if (!rawDefault) {\n                    continue;\n                }\n                const optionCheck = normalizeOptionValue(definition.name, rawDefault);\n                if (!optionCheck.valid) {\n                    continue;\n                }\n                const candidateValue = optionMap.has(definition.name)\n                    ? optionCheck.value\n                    : coerceScalarValue(rawDefault);\n                const validation = validateArgumentValue(definition.name, candidateValue);\n                if (!validation.valid) {\n                    continue;\n                }\n                normalizedArgs[definition.name] = validation.value;\n            }\n        }\n    };\n\n    const autofillWithLanguageModel = async () => {\n        if (!missingRequiredArgs().length) {\n            return false;\n        }\n\n        let agent;\n        try {\n            agent = getAgent();\n        } catch (error) {\n            return false;\n        }\n\n        // First pass: Try FlexSearch for any option-based arguments in the task description\n        const flexSearchPrefills = new Map();\n        for (const argName of missingRequiredArgs()) {\n            if (!optionIndexMap.has(argName)) {\n                continue;\n            }\n            \n            // Try to extract a value from task description for this argument\n            const flexResult = matchOptionWithFlexSearch(argName, taskDescription);\n            if (flexResult.matched && flexResult.confidence >= 0.8) {\n                flexSearchPrefills.set(argName, flexResult.value);\n                if (debugMode) {\n                    console.log(`[FlexSearch] Pre-filled \"${argName}\" from task description`);\n                }\n            }\n        }\n        \n        // Apply FlexSearch prefills\n        for (const [argName, value] of flexSearchPrefills.entries()) {\n            const validation = validateArgumentValue(argName, value);\n            if (validation.valid) {\n                normalizedArgs[argName] = validation.value;\n            }\n        }\n        \n        // If all required args are now filled, we're done\n        if (!missingRequiredArgs().length) {\n            if (debugMode && flexSearchPrefills.size > 0) {\n                console.log(`[FlexSearch] Filled all required arguments without LLM`);\n            }\n            return flexSearchPrefills.size > 0;\n        }\n\n        const allowedKeys = JSON.stringify(allArgumentNames);\n        const skillNameLower = (skill.name || '').toLowerCase();\n        const commandWords = skillNameLower.split(/[-_\\s]+/).filter(Boolean);\n        \n        // Build natural language variations of argument names for voice input\n        // e.g., \"job_name\" \u2192 [\"job_name\", \"job name\", \"jobname\"]\n        const argumentNameVariations = allArgumentNames.map(argName => {\n            const variations = [argName];\n            // Add space-separated version: job_name \u2192 \"job name\"\n            const spaceSeparated = argName.replace(/_/g, ' ');\n            if (spaceSeparated !== argName) {\n                variations.push(spaceSeparated);\n            }\n            // Add no-separator version: job_name \u2192 \"jobname\"\n            const noSeparator = argName.replace(/_/g, '');\n            if (noSeparator !== argName && noSeparator !== spaceSeparated) {\n                variations.push(noSeparator);\n            }\n            return { canonical: argName, variations };\n        });\n        \n        const variationsText = argumentNameVariations\n            .map(({ canonical, variations }) => `\"${canonical}\" can be spoken as: ${variations.map(v => `\"${v}\"`).join(' or ')}`)\n            .join('\\n');\n        \n        // Build type hints for voice input parsing\n        // Only send top 3 FlexSearch matches for options, not all options\n        const typeHints = argumentDefinitions.map(def => {\n            const argType = def.type || 'string';\n            const hasOptions = optionMap.has(def.name);\n            if (hasOptions) {\n                // Try FlexSearch first to get top matches\n                const flexResult = matchOptionWithFlexSearch(def.name, taskDescription);\n                if (flexResult.matches && flexResult.matches.length > 0) {\n                    const topMatches = flexResult.matches.slice(0, 3).map(o => o.label).join(', ');\n                    return `${def.name}: enum/option (top matches: ${topMatches}) - stop at first matching option`;\n                } else {\n                    // No matches or FlexSearch unavailable, send first 3 options\n                    const options = optionMap.get(def.name);\n                    const optionLabels = options.map(o => o.label).slice(0, 3).join(', ');\n                    return `${def.name}: enum/option (sample values: ${optionLabels}${options.length > 3 ? ', ...' : ''}) - stop at first matching option`;\n                }\n            }\n            if (argType === 'number' || argType === 'integer') {\n                return `${def.name}: number - stop at first numeric value`;\n            }\n            if (argType === 'boolean') {\n                return `${def.name}: boolean - stop at true/false`;\n            }\n            return `${def.name}: string - capture all tokens until next argument name`;\n        }).join('\\n');\n        \n        if (debugMode) {\n            console.log('[LLM] Invoking language model for argument extraction');\n        }\n\n        const systemPrompt = `You extract tool arguments from natural language requests, including VOICE INPUT patterns. Respond ONLY with JSON using keys from ${allowedKeys}. Use exact casing.\n\nVOICE INPUT PATTERNS (no quotes in voice):\nWhen you see \"arg_name value value value arg_name2 value2\" pattern:\n- Capture ALL tokens after an argument name until you see another known argument name or end of input\n- For multi-word values, keep all words together until next argument name\n- Stop capturing when you encounter: another argument name, command word, or end of input\n\nARGUMENT NAME RECOGNITION (for voice):\nUsers may speak argument names without underscores. Map these variations to the canonical JSON key:\n${variationsText}\n\nExamples:\n- \"user name\" or \"username\" \u2192 use key \"user_name\"\n- \"first name\" or \"firstname\" \u2192 use key \"first_name\"\n- \"email address\" or \"emailaddress\" \u2192 use key \"email_address\"\n\nTYPE-BASED STOPPING RULES:\n${typeHints}\n\nNATURAL LANGUAGE SEPARATORS (recommended for voice):\n- \"called X\" or \"named X\" \u2192 name-related arguments\n- \"for X\" \u2192 purpose/target arguments\n- \"at X\" or \"in X\" \u2192 location arguments\n- \"with X\" \u2192 additional properties\n- \"status X\" or \"marked as X\" \u2192 status arguments\n\nGENERIC EXAMPLES (adapt to current skill):\n1. Multi-word string values:\n   \"command arg1 value one value two arg2 value three\"\n   \u2192 Capture all words for arg1 until arg2 starts\n\n2. Mixed types:\n   \"command name multi word name quantity 10 status active\"\n   \u2192 Stop at number for quantity, stop at option for status\n\n3. Natural separators:\n   \"command called multi word value for another value\"\n   \u2192 Map natural language to appropriate arguments\n\n4. Simple positional:\n   \"command value1 value2\"\n   \u2192 Extract based on context and task description\n\n5. No parameters:\n   \"command\" with no other words \u2192 {} (empty)\n\nCOMMAND WORDS TO IGNORE: \"${commandWords.join('\", \"')}\"\nUse numbers for numeric fields, booleans for true/false. If value is ambiguous or not mentioned, omit that key.`;\n\n        const sections = [\n            `Skill name: ${skill.name}`,\n            `Skill description: ${skill.description}`,\n            `Existing arguments: ${JSON.stringify(normalizedArgs, null, 2)}`,\n            `Missing arguments: ${JSON.stringify(missingRequiredArgs())}`,\n            `Optional arguments: ${JSON.stringify(missingOptionalArgs())}`,\n        ];\n\n        if (argumentDefinitions.length) {\n            sections.push(`Argument definitions: ${JSON.stringify(argumentDefinitions, null, 2)}`);\n        }\n\n        if (taskDescription && typeof taskDescription === 'string') {\n            sections.push(`Original user request: ${taskDescription}`);\n        }\n\n        sections.push(`Apply the voice input pattern rules above. Remember to capture multi-word values until the next argument name. Map phrases to appropriate arguments. Return JSON only, empty object {} if no parameters found.`);\n\n        let raw;\n        try {\n            raw = await invokeAgent(agent, [\n                { role: 'system', message: systemPrompt },\n                { role: 'human', message: sections.join('\\n\\n') },\n            ], { mode: 'fast' });\n        } catch (error) {\n            return false;\n        }\n\n        const parsed = safeJsonParse(typeof raw === 'string' ? raw.trim() : raw);\n        if (!parsed || typeof parsed !== 'object') {\n            return false;\n        }\n\n        const status = applyUpdatesMap(parsed);\n        if (debugMode && status !== 'unchanged') {\n            console.log(`[LLM] Applied updates from language model: ${JSON.stringify(parsed)}`);\n        }\n        return status !== 'unchanged';\n    };\n\n\n\n\n    const prefillFromTaskDescription = (rawDescription) => {\n        if (typeof rawDescription !== 'string') {\n            return;\n        }\n        const trimmed = rawDescription.trim();\n        if (!trimmed) {\n            return;\n        }\n\n        const attemptPrefill = (name, rawValue) => {\n            if (!allArgumentNames.includes(name)) {\n                return;\n            }\n            if (hasArgumentValue(name)) {\n                return;\n            }\n            const optionCheck = normalizeOptionValue(name, rawValue);\n            if (!optionCheck.valid) {\n                return;\n            }\n            const candidate = optionMap.has(name)\n                ? optionCheck.value\n                : coerceScalarValue(rawValue);\n            const validation = validateArgumentValue(name, candidate);\n            if (!validation.valid) {\n                return;\n            }\n            normalizedArgs[name] = validation.value;\n        };\n\n        const candidateNames = allArgumentNames.length\n            ? allArgumentNames\n            : (requiredArguments.length ? requiredArguments : missingRequiredArgs());\n\n        if (candidateNames.length) {\n            const { resolved: parsed } = parseNamedArguments(trimmed, candidateNames);\n            for (const [name, value] of parsed.entries()) {\n                if (!hasArgumentValue(name)) {\n                    normalizedArgs[name] = value;\n                }\n            }\n        }\n\n        const lowerDescription = trimmed.toLowerCase();\n\n        if (!hasArgumentValue('role')) {\n            if (lowerDescription.includes('system admin')) {\n                attemptPrefill('role', 'SystemAdmin');\n            } else if (lowerDescription.includes('system administrator')) {\n                attemptPrefill('role', 'SystemAdmin');\n            } else if (lowerDescription.includes('project manager')) {\n                attemptPrefill('role', 'ProjectManager');\n            }\n        }\n\n        const stopWords = new Set(['user', 'manager', 'admin', 'administrator', 'system', 'project', 'role', 'password', 'username', 'given', 'family', 'name', 'skip', 'confirmation', 'confirm', 'new', 'add', 'task']);\n\n        const tokens = trimmed.split(/\\s+/);\n        for (let i = tokens.length - 2; i >= 0; i -= 1) {\n            const first = tokens[i];\n            const second = tokens[i + 1];\n            if (!first || !second) {\n                continue;\n            }\n            const isAlpha = (value) => /^[a-z]+$/i.test(value);\n            const isNameCandidate = (value) => isAlpha(value) && !stopWords.has(value.toLowerCase());\n            if (!isNameCandidate(first) || !isNameCandidate(second)) {\n                continue;\n            }\n            const toTitle = (value) => value.length ? value[0].toUpperCase() + value.slice(1).toLowerCase() : value;\n            if (!hasArgumentValue('givenName')) {\n                attemptPrefill('givenName', toTitle(first));\n            }\n            if (!hasArgumentValue('familyName')) {\n                attemptPrefill('familyName', toTitle(second));\n            }\n            break;\n        }\n    };\n\n    const missingRequiredArgs = () => missingArgsFromList(requiredArguments);\n    const missingOptionalArgs = () => missingArgsFromList(optionalArgumentNames);\n\n    const describeArgument = (name) => {\n        const definition = argumentDefinitions.find((arg) => arg.name === name);\n        const options = optionMap.get(name);\n        const descriptionPart = definition?.description ? `: ${definition.description}` : '';\n        const baseLine = `${name}${descriptionPart}`;\n        if (options && options.length) {\n            const lines = options.map(option => `  * ${option.display}`);\n            return [baseLine, 'Options:', ...lines].join('\\n');\n        }\n        return baseLine;\n    };\n\n    const parseableArgumentNames = allArgumentNames.length\n        ? allArgumentNames\n        : (requiredArguments.length ? requiredArguments : []);\n\n    const interpretConfirmationResponse = async (rawInput, summaryText) => {\n        let agent;\n        try {\n            agent = getAgent();\n        } catch (error) {\n            return null;\n        }\n\n        const systemPrompt = 'You interpret confirmation responses for tool execution. Respond ONLY with JSON like {\"action\":\"confirm|cancel|edit\",\"updates\":{\"field\":\"value\"}}. Use lowercase action strings.';\n        const humanSections = [\n            'The user was shown a summary of the pending action and replied as follows.',\n            `User reply: ${rawInput}`,\n            `Current arguments: ${JSON.stringify(normalizedArgs, null, 2)}`,\n        ];\n\n        if (summaryText) {\n            humanSections.push(`Summary shown to user:\\n${summaryText}`);\n        }\n\n        if (argumentDefinitions.length) {\n            humanSections.push(`Argument definitions: ${JSON.stringify(argumentDefinitions, null, 2)}`);\n        }\n\n        humanSections.push('Return JSON only. Use \"confirm\" to proceed, \"cancel\" to stop, or \"edit\" with updates to adjust specific arguments.');\n\n        let raw;\n        try {\n            raw = await invokeAgent(agent, [\n                { role: 'system', message: systemPrompt },\n                { role: 'human', message: humanSections.join('\\n\\n') },\n            ], { mode: 'fast' });\n        } catch (error) {\n            return null;\n        }\n\n        const parsed = safeJsonParse(typeof raw === 'string' ? raw.trim() : raw);\n        if (!parsed || typeof parsed !== 'object') {\n            return null;\n        }\n\n        const action = typeof parsed.action === 'string' ? parsed.action.trim().toLowerCase() : '';\n        const updates = parsed.updates && typeof parsed.updates === 'object' ? parsed.updates : null;\n\n        if (!action) {\n            return null;\n        }\n\n        return { action, updates };\n    };\n\n    const formatArgumentList = (descriptors) => descriptors\n        .map((descriptor) => {\n            if (descriptor === null || descriptor === undefined) {\n                return '';\n            }\n            const lines = String(descriptor).split('\\n');\n            if (!lines.length) {\n                return '';\n            }\n            const [first, ...rest] = lines;\n            const formatted = [`    - ${first}`];\n            for (const line of rest) {\n                formatted.push(line ? `      ${line}` : '      ');\n            }\n            return formatted.join('\\n');\n        })\n        .filter(Boolean)\n        .join('\\n');\n\n    let optionalPromptShown = false;\n\n    const collectMissingArguments = async () => {\n        optionalPromptShown = false;\n\n        while (missingRequiredArgs().length > 0) {\n            const missingRequiredAtStart = missingRequiredArgs();\n            const missingRequired = missingRequiredAtStart;\n            const missingOptional = optionalPromptShown ? [] : missingOptionalArgs();\n\n            const requiredDescriptors = missingRequired.map(describeArgument);\n            const promptSections = ['Missing required arguments:'];\n            const formattedRequired = formatArgumentList(requiredDescriptors);\n            if (formattedRequired) {\n                promptSections.push(formattedRequired);\n            }\n\n            if (missingOptional.length) {\n                const optionalDescriptors = missingOptional.map(describeArgument);\n                const formattedOptional = formatArgumentList(optionalDescriptors);\n                if (formattedOptional) {\n                    promptSections.push('Optional arguments you may also set now:', formattedOptional);\n                } else {\n                    promptSections.push('Optional arguments you may also set now:');\n                }\n                optionalPromptShown = true;\n            }\n\n            promptSections.push(\"Provide values (or type 'cancel' to abort):\\n\");\n\n            const userInput = await readUserPrompt(`${promptSections.join('\\n')}`);\n            const trimmedInput = typeof userInput === 'string' ? userInput.trim() : '';\n\n            if (!trimmedInput) {\n                if (!optionalPromptShown && optionalArgumentNames.length) {\n                    optionalPromptShown = true;\n                }\n                continue;\n            }\n\n            if (trimmedInput.toLowerCase() === 'cancel') {\n                throw new Error('Skill execution cancelled by user.');\n            }\n\n        const parseTargets = parseableArgumentNames.length ? parseableArgumentNames : missingRequired;\n        const { resolved: directlyParsed, invalid: ambiguous } = parseNamedArguments(trimmedInput, parseTargets);\n        for (const [name, value] of directlyParsed.entries()) {\n            normalizedArgs[name] = value;\n        }\n\n        const assignUnlabeledTokens = () => {\n            const rawTokens = trimmedInput.match(/\"[^\"]*\"|'[^']*'|\\S+/g);\n            if (!rawTokens || !rawTokens.length) {\n                return;\n            }\n\n            const normalizedTokens = rawTokens\n                .map((token) => {\n                    const trimmedToken = token.trim();\n                    if (!trimmedToken.length) {\n                        return '';\n                    }\n                    if ((trimmedToken.startsWith('\"') && trimmedToken.endsWith('\"')) || (trimmedToken.startsWith(\"'\") && trimmedToken.endsWith(\"'\"))) {\n                        return trimmedToken.slice(1, -1).trim();\n                    }\n                    return trimmedToken;\n                })\n                .filter(Boolean);\n\n            if (!normalizedTokens.length) {\n                return;\n            }\n\n            const candidateNameSet = new Set(parseTargets.map((name) => name.toLowerCase()));\n            const consumedValueSet = new Set(Array.from(directlyParsed.values())\n                .map((value) => (typeof value === 'string' ? value.trim().toLowerCase() : null))\n                .filter(Boolean));\n\n            const tokensForAssignment = normalizedTokens\n                .filter((token) => !candidateNameSet.has(token.toLowerCase()))\n                .filter((token) => !consumedValueSet.has(token.toLowerCase()));\n\n            if (!tokensForAssignment.length) {\n                return;\n            }\n\n            const takeField = (queue, predicate = () => true) => {\n                const index = queue.findIndex(predicate);\n                if (index === -1) {\n                    return null;\n                }\n                const [field] = queue.splice(index, 1);\n                return field;\n            };\n\n            const requiredQueue = missingRequiredArgs();\n            const optionalQueue = missingOptionalArgs();\n\n            const tryAssignToken = (fieldName, tokenValue) => {\n                if (!fieldName || hasArgumentValue(fieldName)) {\n                    return;\n                }\n\n                let value = tokenValue;\n                const definition = definitionMap.get(fieldName);\n                const fieldType = typeof definition?.type === 'string' ? definition.type.toLowerCase() : '';\n\n                if (optionMap.has(fieldName)) {\n                    const optionCheck = normalizeOptionValue(fieldName, value);\n                    if (!optionCheck.valid) {\n                        return;\n                    }\n                    const validation = validateArgumentValue(fieldName, optionCheck.value);\n                    if (!validation.valid) {\n                        return;\n                    }\n                    normalizedArgs[fieldName] = validation.value;\n                    return;\n                }\n\n                if (fieldType === 'boolean') {\n                    const lower = value.toLowerCase();\n                    if (['true', 'yes', 'y', '1', 'enable', 'enabled', 'allow', 'allowed'].includes(lower)) {\n                        const validation = validateArgumentValue(fieldName, true);\n                        if (!validation.valid) {\n                            return;\n                        }\n                        normalizedArgs[fieldName] = validation.value;\n                        return;\n                    }\n                    if (['false', 'no', 'n', '0', 'disable', 'disabled', 'deny', 'denied'].includes(lower)) {\n                        const validation = validateArgumentValue(fieldName, false);\n                        if (!validation.valid) {\n                            return;\n                        }\n                        normalizedArgs[fieldName] = validation.value;\n                        return;\n                    }\n                }\n\n                if (fieldType === 'integer' || fieldType === 'number') {\n                    const numeric = Number(value);\n                    if (Number.isFinite(numeric)) {\n                        const normalizedNumeric = fieldType === 'integer' ? Math.trunc(numeric) : numeric;\n                        const validation = validateArgumentValue(fieldName, normalizedNumeric);\n                        if (!validation.valid) {\n                            return;\n                        }\n                        normalizedArgs[fieldName] = validation.value;\n                        return;\n                    }\n                }\n\n                if (fieldType && fieldType !== 'string') {\n                    const coerced = coerceScalarValue(value);\n                    const validation = validateArgumentValue(fieldName, coerced);\n                    if (!validation.valid) {\n                        return;\n                    }\n                    normalizedArgs[fieldName] = validation.value;\n                    return;\n                }\n\n                const validation = validateArgumentValue(fieldName, value);\n                if (!validation.valid) {\n                    return;\n                }\n                normalizedArgs[fieldName] = validation.value;\n            };\n\n            for (const token of tokensForAssignment) {\n                const emailField = token.includes('@')\n                    ? takeField(requiredQueue, (name) => {\n                        const definition = definitionMap.get(name);\n                        const description = definition?.description || '';\n                        return /email/i.test(name) || /email/i.test(description);\n                    }) || takeField(optionalQueue, (name) => {\n                        const definition = definitionMap.get(name);\n                        const description = definition?.description || '';\n                        return /email/i.test(name) || /email/i.test(description);\n                    })\n                    : null;\n\n                if (emailField) {\n                    tryAssignToken(emailField, token);\n                    continue;\n                }\n\n                const nextRequired = takeField(requiredQueue);\n                if (nextRequired) {\n                    tryAssignToken(nextRequired, token);\n                    continue;\n                }\n\n                const nextOptional = takeField(optionalQueue);\n                if (nextOptional) {\n                    tryAssignToken(nextOptional, token);\n                }\n            }\n        };\n\n        if (skill.disableAutoTokenAssignment !== true) {\n            assignUnlabeledTokens();\n        }\n\n        if (ambiguous.size) {\n            console.warn(`The following arguments were not understood: ${Array.from(ambiguous).join(', ')}.`);\n        }\n\n            const pendingAfterManual = missingRequiredArgs();\n\n            if (!pendingAfterManual.length) {\n                break;\n            }\n\n            // Try FlexSearch for any remaining option-based arguments before falling back to LLM\n            const flexSearchMatches = new Map();\n            for (const argName of pendingAfterManual) {\n                if (!optionIndexMap.has(argName)) {\n                    continue;\n                }\n                \n                const flexResult = matchOptionWithFlexSearch(argName, trimmedInput);\n                if (flexResult.matched && flexResult.confidence >= 0.8) {\n                    flexSearchMatches.set(argName, flexResult.value);\n                }\n            }\n            \n            // Apply FlexSearch matches\n            for (const [argName, value] of flexSearchMatches.entries()) {\n                const validation = validateArgumentValue(argName, value);\n                if (validation.valid) {\n                    normalizedArgs[argName] = validation.value;\n                    if (debugMode) {\n                        console.log(`[FlexSearch] Matched \"${argName}\" from user input before LLM fallback`);\n                    }\n                }\n            }\n            \n            // Check again if we're done after FlexSearch matching\n            if (!missingRequiredArgs().length) {\n                if (debugMode && flexSearchMatches.size > 0) {\n                    console.log(`[FlexSearch] Filled remaining arguments without LLM`);\n                }\n                break;\n            }\n\n            // Don't invoke LLM if we made progress with manual/FlexSearch assignment\n            // Just loop back to prompt for remaining arguments\n            const currentPending = missingRequiredArgs();\n            if (currentPending.length < missingRequiredAtStart.length) {\n                if (debugMode) {\n                    console.log(`[Skip LLM] Progress made (${missingRequiredAtStart.length - currentPending.length} filled), prompting for remaining ${currentPending.length}`);\n                }\n                continue;\n            }\n\n            let agent;\n            try {\n                agent = getAgent();\n            } catch (error) {\n                throw new Error(`Unable to obtain language model for parsing arguments: ${error.message}`);\n            }\n            \n            if (debugMode) {\n                console.log('[LLM] Falling back to language model for remaining arguments');\n            }\n\n            const systemPrompt = 'You extract structured JSON arguments for tool execution. Respond with JSON only, no commentary.';\n            const humanPromptSections = [\n                `Skill name: ${skill.name}`,\n                `Skill description: ${skill.description}`,\n            ];\n\n            if (argumentDefinitions.length) {\n                humanPromptSections.push(`Argument definitions: ${JSON.stringify(argumentDefinitions, null, 2)}`);\n            }\n\n            humanPromptSections.push(`Missing argument names: ${JSON.stringify(pendingAfterManual)}`);\n            // Only send top 3 FlexSearch matches to LLM, not all options\n            const availableOptions = pendingAfterManual\n                .map((name) => {\n                    const options = optionMap.get(name);\n                    if (!options || !options.length) {\n                        return null;\n                    }\n                    \n                    // Try FlexSearch to get relevant matches first\n                    const flexResult = matchOptionWithFlexSearch(name, trimmedInput);\n                    if (flexResult.matches && flexResult.matches.length > 0) {\n                        const topMatches = flexResult.matches.slice(0, 3).map(option => option.display).join(', ');\n                        return `${name} (top matches): ${topMatches}`;\n                    }\n                    \n                    // No FlexSearch matches, send first 3 options\n                    const formatted = options.slice(0, 3).map(option => option.display).join(', ');\n                    return `${name} (sample options): ${formatted}${options.length > 3 ? ', ...' : ''}`;\n                })\n                .filter(Boolean);\n            if (availableOptions.length) {\n                humanPromptSections.push(`Available options:\\n${availableOptions.join('\\n')}`);\n            }\n            humanPromptSections.push(`User response: ${trimmedInput}`);\n            humanPromptSections.push('Return a JSON object containing values for the missing argument names. Omit any extraneous fields.');\n\n            let rawExtraction;\n            try {\n                rawExtraction = await invokeAgent(agent, [\n                    { role: 'system', message: systemPrompt },\n                    { role: 'human', message: humanPromptSections.join('\\n\\n') },\n                ], { mode: 'fast' });\n            } catch (error) {\n                throw new Error(`Failed to parse arguments with the language model: ${error.message}`);\n            }\n\n            const parsedExtraction = safeJsonParse(typeof rawExtraction === 'string' ? rawExtraction.trim() : rawExtraction);\n\n            if (!parsedExtraction || typeof parsedExtraction !== 'object') {\n                console.warn('The language model did not return valid JSON. Please try providing the details again.');\n                continue;\n            }\n\n            const pendingSet = new Set(pendingAfterManual);\n            const invalidFromModel = new Set();\n            let appliedFromModel = false;\n\n            for (const [name, value] of Object.entries(parsedExtraction)) {\n                if (!pendingSet.has(name)) {\n                    continue;\n                }\n                if (value === undefined || value === null) {\n                    continue;\n                }\n                const optionCheck = normalizeOptionValue(name, value);\n                if (!optionCheck.valid) {\n                    invalidFromModel.add(name);\n                    continue;\n                }\n\n                const candidateValue = optionMap.has(name) ? optionCheck.value : value;\n                const validation = validateArgumentValue(name, candidateValue);\n                if (!validation.valid) {\n                    invalidFromModel.add(name);\n                    continue;\n                }\n\n                normalizedArgs[name] = validation.value;\n                appliedFromModel = true;\n                \n                if (debugMode) {\n                    console.log(`[LLM] Extracted \"${name}\" = ${JSON.stringify(validation.value)}`);\n                }\n            }\n\n            if (invalidFromModel.size) {\n                console.warn(`The model returned unsupported options for arguments: ${Array.from(invalidFromModel).join(', ')}.`);\n            }\n\n            if (!appliedFromModel) {\n                console.warn('Unable to determine values for the remaining arguments. Please provide them again.');\n            }\n        }\n    };\n\n    const isSensitiveName = (name) => typeof name === 'string' && /(password|secret|token|key)/i.test(name);\n\n    const formatSummaryValue = (name, value) => {\n        if (value === undefined) {\n            return '(not provided)';\n        }\n        if (value === null) {\n            return 'null';\n        }\n        if (typeof value === 'string') {\n            if (!value.length) {\n                return '(empty string)';\n            }\n            if (isSensitiveName(name)) {\n                return '********';\n            }\n            return value;\n        }\n        if (typeof value === 'number' || typeof value === 'boolean') {\n            return String(value);\n        }\n        try {\n            return JSON.stringify(value);\n        } catch (error) {\n            return String(value);\n        }\n    };\n\n    const buildConfirmationSummary = () => {\n        const descriptor = skill.humanDescription || skill.description || skill.what || skill.name;\n        const heading = descriptor && descriptor !== skill.name\n            ? `About to execute '${skill.name}': ${descriptor}`\n            : `About to execute '${skill.name}'.`;\n        const lines = [heading];\n\n        const summaryNames = argumentDefinitions.length\n            ? argumentDefinitions.map((def) => def?.name).filter(Boolean)\n            : Array.from(new Set([\n                ...Object.keys(normalizedArgs),\n                ...allArgumentNames,\n                ...requiredArguments,\n                ...optionalArgumentNames,\n            ])).filter(Boolean);\n\n        if (!summaryNames.length) {\n            lines.push('Arguments: (none)');\n            return lines.join('\\n');\n        }\n\n        lines.push('Arguments:');\n        for (const name of summaryNames) {\n            const value = Object.prototype.hasOwnProperty.call(normalizedArgs, name)\n                ? normalizedArgs[name]\n                : undefined;\n            lines.push(`  - ${name}: ${formatSummaryValue(name, value)}`);\n        }\n\n        return lines.join('\\n');\n    };\n\n    const requestArgumentEdits = async () => {\n        const editTargets = parseableArgumentNames.length\n            ? parseableArgumentNames\n            : Array.from(new Set([\n                ...argumentDefinitions.map((def) => def?.name).filter(Boolean),\n                ...Object.keys(normalizedArgs),\n                ...requiredArguments,\n                ...optionalArgumentNames,\n            ])).filter(Boolean);\n\n        if (!editTargets.length) {\n            return 'unchanged';\n        }\n\n        const editInput = await readUserPrompt('Enter updates (e.g., \"password newPass role Admin\") or press Enter to keep current values:\\n');\n        const trimmedEdit = typeof editInput === 'string' ? editInput.trim() : '';\n\n        if (!trimmedEdit) {\n            return 'unchanged';\n        }\n\n        const { resolved: updates, invalid: invalidUpdates } = parseNamedArguments(trimmedEdit, editTargets);\n        const updatesObject = Object.fromEntries(updates);\n        const applyResult = applyUpdatesMap(updatesObject);\n\n        if (invalidUpdates.size) {\n            console.warn(`The following arguments were not understood: ${Array.from(invalidUpdates).join(', ')}.`);\n        }\n\n        return applyResult;\n    };\n\n    if (taskDescription && typeof taskDescription === 'string' && taskDescription.trim()) {\n        prefillFromTaskDescription(taskDescription);\n    }\n\n    await autofillWithLanguageModel();\n    applyDescriptionDefaults();\n\n    let needsArgumentCollection = true;\n\n    while (true) {\n        if (needsArgumentCollection) {\n            await collectMissingArguments();\n            needsArgumentCollection = false;\n        }\n\n        if (skipConfirmation || !skill.needConfirmation) {\n            break;\n        }\n\n        const summary = buildConfirmationSummary();\n        const confirmationInput = await readUserPrompt(`${summary}\\nGo ahead, edit, or cancel?\\n`);\n        const normalizedResponse = typeof confirmationInput === 'string' ? confirmationInput.trim().toLowerCase() : '';\n\n        const affirmatives = new Set(['y', 'yes', 'ok', 'sure', 'do it', 'go ahead', 'proceed']);\n        const negatives = new Set(['c', 'cancel', 'n', 'no', 'stop', 'abort', 'never mind']);\n        const edits = new Set(['e', 'edit', 'change', 'update', 'adjust']);\n\n        if (!normalizedResponse || affirmatives.has(normalizedResponse)) {\n            break;\n        }\n\n        if (negatives.has(normalizedResponse)) {\n            throw new Error('Skill execution cancelled by user.');\n        }\n\n        if (edits.has(normalizedResponse)) {\n            const editResult = await requestArgumentEdits();\n            if (editResult === 'needsMissing') {\n                needsArgumentCollection = true;\n            }\n            continue;\n        }\n\n        const interpreted = await interpretConfirmationResponse(confirmationInput, summary);\n        if (interpreted && interpreted.action) {\n            const action = interpreted.action;\n            if (action === 'confirm' || action === 'yes' || action === 'proceed') {\n                break;\n            }\n            if (action === 'cancel' || action === 'stop' || action === 'abort') {\n                throw new Error('Skill execution cancelled by user.');\n            }\n            if (action === 'edit') {\n                if (interpreted.updates && Object.keys(interpreted.updates).length) {\n                    const editResult = applyUpdatesMap(interpreted.updates);\n                    if (editResult === 'needsMissing') {\n                        needsArgumentCollection = true;\n                    } else if (editResult === 'unchanged') {\n                        console.log('I could not apply those changes. Let\u2019s try again together.');\n                        const manualResult = await requestArgumentEdits();\n                        if (manualResult === 'needsMissing') {\n                            needsArgumentCollection = true;\n                        }\n                    }\n                    continue;\n                }\n                const manualResult = await requestArgumentEdits();\n                if (manualResult === 'needsMissing') {\n                    needsArgumentCollection = true;\n                }\n                continue;\n            }\n        }\n\n        console.log(\"Please answer in your own words\u2014for example 'yes', 'edit', or 'cancel'.\");\n    }\n\n    const orderedNames = argumentDefinitions.length\n        ? argumentDefinitions.map(def => def.name)\n        : requiredArguments.slice();\n\n    if (!orderedNames.length) {\n        return action({ ...normalizedArgs });\n    }\n\n    const positionalValues = orderedNames.map(name => normalizedArgs[name]);\n\n    if (action.length > 1) {\n        return action(...positionalValues);\n    }\n\n    if (orderedNames.length === 1) {\n        return action(positionalValues[0]);\n    }\n\n    return action({ ...normalizedArgs });\n}\n\nexport {\n    executeSkill,\n};\n", "const CONTEXT_ROLE_ALIASES = new Map([\n    ['system', 'system'],\n    ['user', 'human'],\n    ['human', 'human'],\n    ['assistant', 'assistant'],\n    ['tool', 'assistant'],\n    ['function', 'assistant'],\n    ['observation', 'assistant'],\n]);\n\nconst TOOL_LIKE_ROLES = new Set(['tool', 'function', 'observation']);\n\nfunction limitPreview(value, maxLength = 400) {\n    if (value === undefined || value === null) {\n        return '';\n    }\n    let text;\n    if (typeof value === 'string') {\n        text = value;\n    } else {\n        try {\n            text = JSON.stringify(value);\n        } catch (error) {\n            text = String(value);\n        }\n    }\n    if (text.length <= maxLength) {\n        return text;\n    }\n    return `${text.slice(0, Math.max(0, maxLength - 3))}...`;\n}\n\nfunction buildSuggestionBlock(title, lines) {\n    if (!lines || !lines.length) {\n        return null;\n    }\n    const body = lines.map(line => `- ${line}`).join('\\n');\n    return `${title}:\\n${body}`;\n}\n\nfunction normalizeAgentKind(value) {\n    const normalized = String(value || '').trim().toLowerCase();\n    return normalized === 'chat' ? 'chat' : 'task';\n}\n\nfunction buildAgentDescription(agent) {\n    const kind = normalizeAgentKind(agent?.kind);\n    const isChat = kind === 'chat';\n    const classification = isChat ? 'Expert Conversationalist' : 'Expert Task Executor';\n    const role = agent?.role ? String(agent.role).trim() : '';\n    const job = agent?.job ? String(agent.job).trim() : '';\n    const expertise = agent?.expertise ? String(agent.expertise).trim() : '';\n    const instructions = agent?.instructions ? String(agent.instructions).trim() : '';\n    const details = [\n        `Type: ${kind}`,\n        `Classification: ${classification}`,\n        role && `Role: ${role}`,\n        job && `Job: ${job}`,\n        expertise && `Expertise: ${expertise}`,\n        instructions && `Guidance: ${instructions}`,\n    ].filter(Boolean).join(' | ');\n    return details;\n}\n\nfunction normalizeTaskContext(_agent, context) {\n    if (Array.isArray(context)) {\n        const normalizedMessages = context\n            .map((entry) => {\n                if (!entry || typeof entry !== 'object') {\n                    return null;\n                }\n\n                const rawRole = typeof entry.role === 'string' ? entry.role.trim().toLowerCase() : '';\n                const role = CONTEXT_ROLE_ALIASES.get(rawRole);\n                if (!role) {\n                    return null;\n                }\n\n                let message = entry.message;\n                if (typeof message === 'undefined' || message === null) {\n                    message = entry.content;\n                }\n                if (typeof message === 'undefined' || message === null) {\n                    message = entry.result;\n                }\n                if (typeof message === 'undefined' || message === null) {\n                    message = entry.output;\n                }\n                if (typeof message === 'undefined' || message === null) {\n                    return null;\n                }\n\n                if (typeof message === 'object') {\n                    try {\n                        message = JSON.stringify(message, null, 2);\n                    } catch (error) {\n                        message = String(message);\n                    }\n                }\n\n                if (TOOL_LIKE_ROLES.has(rawRole)) {\n                    const label = entry.name ? `${rawRole}:${entry.name}` : rawRole;\n                    message = `[${label}] ${String(message)}`;\n                }\n\n                return {\n                    role,\n                    message: String(message),\n                };\n            })\n            .filter(Boolean);\n\n        if (normalizedMessages.length) {\n            return {\n                type: 'messages',\n                messages: normalizedMessages,\n            };\n        }\n\n        return {\n            type: 'text',\n            text: '',\n        };\n    }\n\n    const trimmed = context ? String(context).trim() : '';\n    return {\n        type: 'text',\n        text: trimmed,\n    };\n}\n\nfunction buildSystemHistory(agent, { instruction, context, description, outputSchema, extraContextParts = [] }) {\n    const history = [];\n    const agentLabel = agent.canonicalName || agent.name;\n    const agentDescription = buildAgentDescription(agent);\n    history.push({\n        role: 'system',\n        message: `You are the ${agentLabel} agent. ${agentDescription} ${instruction}`.trim(),\n    });\n\n    const normalizedContext = context && typeof context === 'object' && (context.type === 'text' || context.type === 'messages')\n        ? context\n        : normalizeTaskContext(agent, context);\n\n    if (normalizedContext.type === 'messages') {\n        for (const entry of normalizedContext.messages) {\n            history.push({ role: entry.role, message: entry.message });\n        }\n    }\n\n    const parts = [];\n    if (normalizedContext.type === 'text' && normalizedContext.text) {\n        parts.push(`Context:\\n${normalizedContext.text}`);\n    }\n\n    if (Array.isArray(extraContextParts) && extraContextParts.length) {\n        for (const part of extraContextParts) {\n            if (part) {\n                parts.push(part);\n            }\n        }\n    }\n\n    if (description) {\n        parts.push(`Task:\\n${description}`);\n    }\n    if (outputSchema) {\n        parts.push(`Desired output schema (JSON Schema):\\n${JSON.stringify(outputSchema, null, 2)}`);\n        parts.push('Respond with JSON that strictly matches the schema.');\n    }\n\n    if (parts.length) {\n        history.push({\n            role: 'human',\n            message: parts.join('\\n\\n'),\n        });\n    }\n\n    return history;\n}\n\nexport {\n    CONTEXT_ROLE_ALIASES,\n    TOOL_LIKE_ROLES,\n    buildAgentDescription,\n    buildSuggestionBlock,\n    buildSystemHistory,\n    limitPreview,\n    normalizeTaskContext,\n};\n", "import {\n    buildSuggestionBlock,\n    buildSystemHistory,\n    limitPreview,\n    normalizeTaskContext,\n} from '../context/contextBuilder.mjs';\nimport { invokeAgent } from '../invocation/modelInvoker.mjs';\nimport { ensureAgentRegistry, getAgent } from '../agents/agentRegistry.mjs';\nimport { safeJsonParse } from '../utils/json.mjs';\n\nfunction normalizeTaskMode(mode, outputSchema, agent, fallback = 'fast') {\n    const normalized = (mode || '').toLowerCase();\n    const agentModes = Array.isArray(agent?.supportedModes) ? agent.supportedModes.slice() : [];\n    if (!agentModes.length && agent?.modelMode) {\n        agentModes.push(agent.modelMode);\n    }\n\n    const supportsMode = (candidate) => {\n        if (!candidate) {\n            return false;\n        }\n        if (typeof agent?.supportsMode === 'function') {\n            return agent.supportsMode(candidate);\n        }\n        return agentModes.includes(candidate);\n    };\n\n    if (normalized === 'deep' || normalized === 'fast') {\n        return supportsMode(normalized) ? normalized : (supportsMode(fallback) ? fallback : (agentModes[0] || fallback));\n    }\n\n    if (normalized === 'any' || normalized === '') {\n        if (outputSchema && supportsMode('deep')) {\n            return 'deep';\n        }\n        if (supportsMode('fast')) {\n            return 'fast';\n        }\n        if (supportsMode('deep')) {\n            return 'deep';\n        }\n    }\n\n    if (supportsMode(fallback)) {\n        return fallback;\n    }\n\n    return agentModes[0] || fallback;\n}\n\nasync function executeFastTask(agent, context, description, outputSchema) {\n    const contextInfo = normalizeTaskContext(agent, context);\n    const history = buildSystemHistory(agent, {\n        instruction: 'Complete the task in a single response.',\n        context: contextInfo,\n        description,\n        outputSchema,\n        mode: 'fast',\n    });\n    const raw = await invokeAgent(agent, history, { mode: 'fast' });\n    return buildTaskResult(raw, outputSchema);\n}\n\nasync function generatePlan(agent, context, description, options = {}) {\n    const contextInfo = normalizeTaskContext(agent, context);\n    const hints = Array.isArray(options.hints) ? options.hints : [];\n    const extraParts = [];\n    if (hints.length) {\n        const lines = hints.slice(0, 3).map((hint, index) => {\n            const steps = Array.isArray(hint?.steps) ? hint.steps.slice(0, 3).map((step, stepIndex) => `${stepIndex + 1}. ${typeof step === 'string' ? step : JSON.stringify(step)}`).join(' | ') : limitPreview(hint, 200);\n            return `Plan #${index + 1}: ${steps}`;\n        });\n        const block = buildSuggestionBlock('Candidate plans for reuse', lines);\n        if (block) {\n            extraParts.push(block);\n        }\n    }\n\n    const history = buildSystemHistory(agent, {\n        instruction: 'Create a concise step-by-step plan for the task before solving it.',\n        context: contextInfo,\n        description,\n        outputSchema: { type: 'object', properties: { steps: { type: 'array' } }, required: ['steps'] },\n        mode: 'deep',\n        extraContextParts: extraParts,\n    });\n\n    const raw = await invokeAgent(agent, history, { mode: 'deep' });\n    const parsed = safeJsonParse(raw);\n\n    if (parsed?.steps && Array.isArray(parsed.steps)) {\n        return parsed;\n    }\n\n    return { steps: Array.from(String(raw).split('\\n').filter(Boolean)).map((line, index) => ({ id: index + 1, action: line.trim() })) };\n}\n\nasync function executeDeepTask(agent, context, description, outputSchema) {\n    const contextInfo = normalizeTaskContext(agent, context);\n    const plan = await generatePlan(agent, context, description);\n\n    const extraParts = [`Plan:\\n${JSON.stringify(plan)}`];\n\n    const executionHistory = buildSystemHistory(agent, {\n        instruction: 'Follow the plan and produce a final answer. Iterate internally as needed.',\n        context: contextInfo,\n        extraContextParts: extraParts,\n        description,\n        outputSchema,\n        mode: 'deep',\n    });\n    const raw = await invokeAgent(agent, executionHistory, { mode: 'deep' });\n    return buildTaskResult(raw, outputSchema);\n}\n\nasync function executeIteration(agent, context, description, outputSchema, iteration, feedback, plan, mode, options = {}) {\n    const contextInfo = normalizeTaskContext(agent, context);\n    const extraParts = [`Task:\\n${description}`, `Iteration: ${iteration}`];\n    if (plan) {\n        extraParts.push(`Plan:\\n${JSON.stringify(plan)}`);\n    }\n    if (feedback) {\n        extraParts.push(`Prior feedback:\\n${feedback}`);\n    }\n    const hints = Array.isArray(options.hints) ? options.hints : [];\n    if (hints.length) {\n        const block = buildSuggestionBlock('Retrieved guidance', hints.map((hint, index) => `${index + 1}. ${limitPreview(hint, 200)}`));\n        if (block) {\n            extraParts.push(block);\n        }\n    }\n\n    const history = buildSystemHistory(agent, {\n        instruction: 'Work step-by-step, applying the plan and feedback to improve the solution.',\n        context: contextInfo,\n        extraContextParts: extraParts,\n        description: 'Return only the updated solution, no commentary unless necessary.',\n        outputSchema,\n        mode,\n    });\n    const raw = await invokeAgent(agent, history, { mode });\n    const parsed = buildTaskResult(raw, outputSchema);\n    return { raw, parsed };\n}\n\nasync function reviewCandidate(agent, context, description, candidate, outputSchema, iteration, mode) {\n    const contextInfo = normalizeTaskContext(agent, context || 'N/A');\n    const reviewHistory = buildSystemHistory(agent, {\n        instruction: 'Review the candidate solution for quality, correctness, and alignment with the task.',\n        context: contextInfo,\n        extraContextParts: [\n            `Task:\\n${description}`,\n            `Iteration: ${iteration}`,\n            `Candidate:\\n${candidate}`,\n        ],\n        description: 'Return JSON:{\"approved\":boolean,\"feedback\":string}.',\n        outputSchema: null,\n        mode,\n    });\n\n    const reviewRaw = await invokeAgent(agent, reviewHistory, { mode });\n    const review = safeJsonParse(reviewRaw);\n\n    if (typeof review?.approved !== 'boolean') {\n        return { approved: false, feedback: 'Review response invalid; improve the solution with more rigor.' };\n    }\n\n    return { approved: review.approved, feedback: review.feedback };\n}\n\nfunction buildTaskResult(raw, outputSchema) {\n    if (!outputSchema) {\n        return { result: raw };\n    }\n\n    const parsed = safeJsonParse(raw);\n    if (!parsed || typeof parsed !== 'object') {\n        return { result: raw };\n    }\n    return parsed;\n}\n\nfunction buildEvaluationContext(question, generationResults, reviewCriteria) {\n    return JSON.stringify({\n        question,\n        reviewCriteria: reviewCriteria || 'Use balanced judgement for quality and relevance.',\n        alternatives: generationResults.map(entry => ({ index: entry.index, agent: entry.agent, content: entry.content })),\n    }, null, 2);\n}\n\nasync function brainstormQuestion(agentName, question, generationCount, returnCount, reviewCriteria = null) {\n    if (!question) {\n        throw new Error('question is required for brainstorm.');\n    }\n    if (!Number.isInteger(generationCount) || generationCount < 1) {\n        throw new Error('generationCount must be a positive integer.');\n    }\n    if (!Number.isInteger(returnCount) || returnCount < 1) {\n        throw new Error('returnCount must be a positive integer.');\n    }\n\n    const registry = ensureAgentRegistry();\n    const agents = Array.from(registry.values());\n    if (!agents.length) {\n        throw new Error('No agents available for brainstorming.');\n    }\n\n    const generationResults = [];\n    let nextIndex = 1;\n\n    let generatedCount = 0;\n    while (generationResults.length < generationCount) {\n        const agent = agents[generatedCount % agents.length];\n        const history = buildSystemHistory(agent, {\n            instruction: 'Generate one creative, self-contained answer option.',\n            context: '',\n            description: `Question: ${question}\\nYou are variant #${nextIndex}.`,\n            mode: 'fast',\n        });\n        const raw = await invokeAgent(agent, history, { mode: 'fast' });\n        generationResults.push({ index: nextIndex, agent: agent.name, content: raw });\n        nextIndex += 1;\n        generatedCount += 1;\n    }\n\n    const evaluator = getAgent(agentName);\n    const evaluationMode = evaluator.supportsMode && evaluator.supportsMode('deep') ? 'deep' : 'fast';\n    const evaluationHistory = buildSystemHistory(evaluator, {\n        instruction: 'Evaluate brainstormed alternatives and return the top choices ranked by quality.',\n        context: buildEvaluationContext(question, generationResults, reviewCriteria),\n        description: 'Return JSON with property \"ranked\" listing objects {\"index\": number, \"score\": number, \"rationale\": string}.',\n        mode: evaluationMode,\n    });\n    const evaluationRaw = await invokeAgent(evaluator, evaluationHistory, { mode: evaluationMode });\n    const evaluation = safeJsonParse(evaluationRaw);\n\n    if (!evaluation?.ranked || !Array.isArray(evaluation.ranked)) {\n        throw new Error('Brainstorm evaluation response did not include ranked results.');\n    }\n\n    const ranked = evaluation.ranked\n        .filter(entry => typeof entry.index === 'number')\n        .slice(0, returnCount);\n\n    return ranked.map(entry => {\n        const match = generationResults.find(option => option.index === entry.index);\n        if (!match) {\n            return null;\n        }\n        return {\n            choice: match.content,\n            metadata: {\n                agent: match.agent,\n                index: match.index,\n                score: entry.score,\n                rationale: entry.rationale,\n            }\n        };\n    }).filter(Boolean);\n}\n\nexport {\n    brainstormQuestion,\n    buildEvaluationContext,\n    buildTaskResult,\n    executeDeepTask,\n    executeFastTask,\n    executeIteration,\n    generatePlan,\n    normalizeTaskMode,\n    reviewCandidate,\n};\n", "import {\n    buildSystemHistory,\n    normalizeTaskContext,\n} from '../context/contextBuilder.mjs';\nimport { getAgent } from '../agents/agentRegistry.mjs';\nimport { invokeAgent } from '../invocation/modelInvoker.mjs';\nimport { normalizeTaskMode } from '../tasks/taskRunner.mjs';\nimport { safeJsonParse } from '../utils/json.mjs';\n\nconst operatorRegistry = new Map();\n\nfunction registerOperator(operatorName, description, executionCallback) {\n    if (!operatorName || typeof operatorName !== 'string') {\n        throw new Error('operatorName must be a non-empty string.');\n    }\n    if (!/^[a-z][a-zA-Z0-9-]*$/.test(operatorName)) {\n        throw new Error('operatorName must start with a lowercase letter and can only contain alphanumeric characters and dashes.');\n    }\n    if (!description || typeof description !== 'string') {\n        throw new Error('description must be a non-empty string.');\n    }\n    if (typeof executionCallback !== 'function') {\n        throw new Error('executionCallback must be a function.');\n    }\n    if (operatorRegistry.has(operatorName)) {\n        throw new Error(`Operator \"${operatorName}\" is already registered.`);\n    }\n\n    operatorRegistry.set(operatorName, {\n        name: operatorName,\n        description,\n        execute: executionCallback,\n    });\n}\n\nasync function callOperator(operatorName, params = {}) {\n    if (!operatorRegistry.has(operatorName)) {\n        throw new Error(`Operator \"${operatorName}\" is not registered.`);\n    }\n    const operator = operatorRegistry.get(operatorName);\n    return operator.execute(params || {});\n}\n\nasync function chooseOperator(agentName, currentTaskDescription, mode = 'fast', threshold = 0.5) {\n    if (!operatorRegistry.size) {\n        return { suitableOperators: [] };\n    }\n\n    const agent = getAgent(agentName);\n    const normalizedMode = normalizeTaskMode(mode, null, agent, 'fast');\n\n    const operatorList = Array.from(operatorRegistry.values()).map(op => ({\n        operatorName: op.name,\n        description: op.description,\n    }));\n\n    const contextInfo = normalizeTaskContext(agent, JSON.stringify({ operators: operatorList }, null, 2));\n    const history = buildSystemHistory(agent, {\n        instruction: normalizedMode === 'deep'\n            ? 'Review the operator catalog and select the functions that can help with the task.'\n            : 'Quickly select operators that can solve the task.',\n        context: contextInfo,\n        description: `Task description: ${currentTaskDescription}\\nOnly return JSON: {\"suitableOperators\":[{\"operatorName\": string, \"confidence\": number}]}. Discard operators below confidence ${threshold}.`,\n        mode: normalizedMode,\n    });\n\n    const raw = await invokeAgent(agent, history, { mode: normalizedMode });\n    const parsed = safeJsonParse(raw);\n\n    if (parsed?.suitableOperators) {\n        const filtered = parsed.suitableOperators.filter(op => typeof op.confidence === 'number' && op.confidence >= threshold);\n        return { suitableOperators: filtered };\n    }\n\n    if (typeof raw === 'string') {\n        const jsonMatch = raw.match(/\\{[\\s\\S]*\\}/);\n        if (jsonMatch) {\n            const robustParsed = safeJsonParse(jsonMatch[0]);\n            if (robustParsed?.suitableOperators) {\n                const filtered = robustParsed.suitableOperators.filter(op => typeof op.confidence === 'number' && op.confidence >= threshold);\n                return { suitableOperators: filtered };\n            }\n        }\n    }\n\n    throw new Error('Operator selection response is invalid.');\n}\n\nfunction hasOperators() {\n    return operatorRegistry.size > 0;\n}\n\nfunction resetOperatorRegistry() {\n    operatorRegistry.clear();\n}\n\nexport {\n    callOperator,\n    chooseOperator,\n    hasOperators,\n    registerOperator,\n    resetOperatorRegistry,\n};\n"],
  "mappings": "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",
  "names": ["callLLM", "callLLM", "callLLM", "callLLM", "callLLM", "callLLM", "path", "path", "exports", "modelsConfiguration", "modelsConfiguration", "record", "modelsConfiguration", "registry", "action", "validation", "manualResult", "registry", "registerDefaultLLMAgent", "listAgents"]
}
